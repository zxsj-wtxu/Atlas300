// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ai_types.proto

#ifndef PROTOBUF_ai_5ftypes_2eproto__INCLUDED
#define PROTOBUF_ai_5ftypes_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace protobuf_ai_5ftypes_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[16];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsAITensorParaDescriptionImpl();
void InitDefaultsAITensorParaDescription();
void InitDefaultsAITensorDescriptionImpl();
void InitDefaultsAITensorDescription();
void InitDefaultsAITensorDescriptionListImpl();
void InitDefaultsAITensorDescriptionList();
void InitDefaultsAIConfigItemImpl();
void InitDefaultsAIConfigItem();
void InitDefaultsAIConfigImpl();
void InitDefaultsAIConfig();
void InitDefaultsAIModelDescriptionImpl();
void InitDefaultsAIModelDescription();
void InitDefaultsAINNNodeDescriptionImpl();
void InitDefaultsAINNNodeDescription();
void InitDefaultsAINNNodeDescriptionListImpl();
void InitDefaultsAINNNodeDescriptionList();
void InitDefaultsAIAPIDescriptionImpl();
void InitDefaultsAIAPIDescription();
void InitDefaultsAIAPIDescriptionListImpl();
void InitDefaultsAIAPIDescriptionList();
void InitDefaultsAIOPDescriptionImpl();
void InitDefaultsAIOPDescription();
void InitDefaultsAIOPDescriptionListImpl();
void InitDefaultsAIOPDescriptionList();
void InitDefaultsNodeDescImpl();
void InitDefaultsNodeDesc();
void InitDefaultsEngineDescImpl();
void InitDefaultsEngineDesc();
void InitDefaultsGraphInitDescImpl();
void InitDefaultsGraphInitDesc();
void InitDefaultsGeneralFileBufferImpl();
void InitDefaultsGeneralFileBuffer();
inline void InitDefaults() {
  InitDefaultsAITensorParaDescription();
  InitDefaultsAITensorDescription();
  InitDefaultsAITensorDescriptionList();
  InitDefaultsAIConfigItem();
  InitDefaultsAIConfig();
  InitDefaultsAIModelDescription();
  InitDefaultsAINNNodeDescription();
  InitDefaultsAINNNodeDescriptionList();
  InitDefaultsAIAPIDescription();
  InitDefaultsAIAPIDescriptionList();
  InitDefaultsAIOPDescription();
  InitDefaultsAIOPDescriptionList();
  InitDefaultsNodeDesc();
  InitDefaultsEngineDesc();
  InitDefaultsGraphInitDesc();
  InitDefaultsGeneralFileBuffer();
}
}  // namespace protobuf_ai_5ftypes_2eproto
namespace hiai {
class AIAPIDescription;
class AIAPIDescriptionDefaultTypeInternal;
extern AIAPIDescriptionDefaultTypeInternal _AIAPIDescription_default_instance_;
class AIAPIDescriptionList;
class AIAPIDescriptionListDefaultTypeInternal;
extern AIAPIDescriptionListDefaultTypeInternal _AIAPIDescriptionList_default_instance_;
class AIConfig;
class AIConfigDefaultTypeInternal;
extern AIConfigDefaultTypeInternal _AIConfig_default_instance_;
class AIConfigItem;
class AIConfigItemDefaultTypeInternal;
extern AIConfigItemDefaultTypeInternal _AIConfigItem_default_instance_;
class AIModelDescription;
class AIModelDescriptionDefaultTypeInternal;
extern AIModelDescriptionDefaultTypeInternal _AIModelDescription_default_instance_;
class AINNNodeDescription;
class AINNNodeDescriptionDefaultTypeInternal;
extern AINNNodeDescriptionDefaultTypeInternal _AINNNodeDescription_default_instance_;
class AINNNodeDescriptionList;
class AINNNodeDescriptionListDefaultTypeInternal;
extern AINNNodeDescriptionListDefaultTypeInternal _AINNNodeDescriptionList_default_instance_;
class AIOPDescription;
class AIOPDescriptionDefaultTypeInternal;
extern AIOPDescriptionDefaultTypeInternal _AIOPDescription_default_instance_;
class AIOPDescriptionList;
class AIOPDescriptionListDefaultTypeInternal;
extern AIOPDescriptionListDefaultTypeInternal _AIOPDescriptionList_default_instance_;
class AITensorDescription;
class AITensorDescriptionDefaultTypeInternal;
extern AITensorDescriptionDefaultTypeInternal _AITensorDescription_default_instance_;
class AITensorDescriptionList;
class AITensorDescriptionListDefaultTypeInternal;
extern AITensorDescriptionListDefaultTypeInternal _AITensorDescriptionList_default_instance_;
class AITensorParaDescription;
class AITensorParaDescriptionDefaultTypeInternal;
extern AITensorParaDescriptionDefaultTypeInternal _AITensorParaDescription_default_instance_;
class EngineDesc;
class EngineDescDefaultTypeInternal;
extern EngineDescDefaultTypeInternal _EngineDesc_default_instance_;
class GeneralFileBuffer;
class GeneralFileBufferDefaultTypeInternal;
extern GeneralFileBufferDefaultTypeInternal _GeneralFileBuffer_default_instance_;
class GraphInitDesc;
class GraphInitDescDefaultTypeInternal;
extern GraphInitDescDefaultTypeInternal _GraphInitDesc_default_instance_;
class NodeDesc;
class NodeDescDefaultTypeInternal;
extern NodeDescDefaultTypeInternal _NodeDesc_default_instance_;
}  // namespace hiai
namespace hiai {

enum AIModelDescription_Frequency {
  AIModelDescription_Frequency_UNSET = 0,
  AIModelDescription_Frequency_LOW = 1,
  AIModelDescription_Frequency_MEDIUM = 2,
  AIModelDescription_Frequency_HIGH = 3,
  AIModelDescription_Frequency_AIModelDescription_Frequency_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  AIModelDescription_Frequency_AIModelDescription_Frequency_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool AIModelDescription_Frequency_IsValid(int value);
const AIModelDescription_Frequency AIModelDescription_Frequency_Frequency_MIN = AIModelDescription_Frequency_UNSET;
const AIModelDescription_Frequency AIModelDescription_Frequency_Frequency_MAX = AIModelDescription_Frequency_HIGH;
const int AIModelDescription_Frequency_Frequency_ARRAYSIZE = AIModelDescription_Frequency_Frequency_MAX + 1;

const ::google::protobuf::EnumDescriptor* AIModelDescription_Frequency_descriptor();
inline const ::std::string& AIModelDescription_Frequency_Name(AIModelDescription_Frequency value) {
  return ::google::protobuf::internal::NameOfEnum(
    AIModelDescription_Frequency_descriptor(), value);
}
inline bool AIModelDescription_Frequency_Parse(
    const ::std::string& name, AIModelDescription_Frequency* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AIModelDescription_Frequency>(
    AIModelDescription_Frequency_descriptor(), name, value);
}
enum AIModelDescription_DeviceType {
  AIModelDescription_DeviceType_NPU = 0,
  AIModelDescription_DeviceType_IPU = 1,
  AIModelDescription_DeviceType_MLU = 2,
  AIModelDescription_DeviceType_CPU = 3,
  AIModelDescription_DeviceType_NONE = 255,
  AIModelDescription_DeviceType_AIModelDescription_DeviceType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  AIModelDescription_DeviceType_AIModelDescription_DeviceType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool AIModelDescription_DeviceType_IsValid(int value);
const AIModelDescription_DeviceType AIModelDescription_DeviceType_DeviceType_MIN = AIModelDescription_DeviceType_NPU;
const AIModelDescription_DeviceType AIModelDescription_DeviceType_DeviceType_MAX = AIModelDescription_DeviceType_NONE;
const int AIModelDescription_DeviceType_DeviceType_ARRAYSIZE = AIModelDescription_DeviceType_DeviceType_MAX + 1;

const ::google::protobuf::EnumDescriptor* AIModelDescription_DeviceType_descriptor();
inline const ::std::string& AIModelDescription_DeviceType_Name(AIModelDescription_DeviceType value) {
  return ::google::protobuf::internal::NameOfEnum(
    AIModelDescription_DeviceType_descriptor(), value);
}
inline bool AIModelDescription_DeviceType_Parse(
    const ::std::string& name, AIModelDescription_DeviceType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AIModelDescription_DeviceType>(
    AIModelDescription_DeviceType_descriptor(), name, value);
}
enum AIModelDescription_Framework {
  AIModelDescription_Framework_OFFLINE = 0,
  AIModelDescription_Framework_CAFFE = 1,
  AIModelDescription_Framework_TENSORFLOW = 2,
  AIModelDescription_Framework_AIModelDescription_Framework_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  AIModelDescription_Framework_AIModelDescription_Framework_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool AIModelDescription_Framework_IsValid(int value);
const AIModelDescription_Framework AIModelDescription_Framework_Framework_MIN = AIModelDescription_Framework_OFFLINE;
const AIModelDescription_Framework AIModelDescription_Framework_Framework_MAX = AIModelDescription_Framework_TENSORFLOW;
const int AIModelDescription_Framework_Framework_ARRAYSIZE = AIModelDescription_Framework_Framework_MAX + 1;

const ::google::protobuf::EnumDescriptor* AIModelDescription_Framework_descriptor();
inline const ::std::string& AIModelDescription_Framework_Name(AIModelDescription_Framework value) {
  return ::google::protobuf::internal::NameOfEnum(
    AIModelDescription_Framework_descriptor(), value);
}
inline bool AIModelDescription_Framework_Parse(
    const ::std::string& name, AIModelDescription_Framework* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AIModelDescription_Framework>(
    AIModelDescription_Framework_descriptor(), name, value);
}
enum AIOPDescription_OP_Type {
  AIOPDescription_OP_Type_AI_API = 0,
  AIOPDescription_OP_Type_AI_NNNODE = 1,
  AIOPDescription_OP_Type_AIOPDescription_OP_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  AIOPDescription_OP_Type_AIOPDescription_OP_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool AIOPDescription_OP_Type_IsValid(int value);
const AIOPDescription_OP_Type AIOPDescription_OP_Type_OP_Type_MIN = AIOPDescription_OP_Type_AI_API;
const AIOPDescription_OP_Type AIOPDescription_OP_Type_OP_Type_MAX = AIOPDescription_OP_Type_AI_NNNODE;
const int AIOPDescription_OP_Type_OP_Type_ARRAYSIZE = AIOPDescription_OP_Type_OP_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* AIOPDescription_OP_Type_descriptor();
inline const ::std::string& AIOPDescription_OP_Type_Name(AIOPDescription_OP_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    AIOPDescription_OP_Type_descriptor(), value);
}
inline bool AIOPDescription_OP_Type_Parse(
    const ::std::string& name, AIOPDescription_OP_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AIOPDescription_OP_Type>(
    AIOPDescription_OP_Type_descriptor(), name, value);
}
enum EngineDesc_RunSide {
  EngineDesc_RunSide_DEVICE = 0,
  EngineDesc_RunSide_HOST = 1,
  EngineDesc_RunSide_EngineDesc_RunSide_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  EngineDesc_RunSide_EngineDesc_RunSide_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool EngineDesc_RunSide_IsValid(int value);
const EngineDesc_RunSide EngineDesc_RunSide_RunSide_MIN = EngineDesc_RunSide_DEVICE;
const EngineDesc_RunSide EngineDesc_RunSide_RunSide_MAX = EngineDesc_RunSide_HOST;
const int EngineDesc_RunSide_RunSide_ARRAYSIZE = EngineDesc_RunSide_RunSide_MAX + 1;

const ::google::protobuf::EnumDescriptor* EngineDesc_RunSide_descriptor();
inline const ::std::string& EngineDesc_RunSide_Name(EngineDesc_RunSide value) {
  return ::google::protobuf::internal::NameOfEnum(
    EngineDesc_RunSide_descriptor(), value);
}
inline bool EngineDesc_RunSide_Parse(
    const ::std::string& name, EngineDesc_RunSide* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EngineDesc_RunSide>(
    EngineDesc_RunSide_descriptor(), name, value);
}
enum EngineDesc_EngineType {
  EngineDesc_EngineType_NORMAL = 0,
  EngineDesc_EngineType_SOURCE = 1,
  EngineDesc_EngineType_DEST = 2,
  EngineDesc_EngineType_EngineDesc_EngineType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  EngineDesc_EngineType_EngineDesc_EngineType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool EngineDesc_EngineType_IsValid(int value);
const EngineDesc_EngineType EngineDesc_EngineType_EngineType_MIN = EngineDesc_EngineType_NORMAL;
const EngineDesc_EngineType EngineDesc_EngineType_EngineType_MAX = EngineDesc_EngineType_DEST;
const int EngineDesc_EngineType_EngineType_ARRAYSIZE = EngineDesc_EngineType_EngineType_MAX + 1;

const ::google::protobuf::EnumDescriptor* EngineDesc_EngineType_descriptor();
inline const ::std::string& EngineDesc_EngineType_Name(EngineDesc_EngineType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EngineDesc_EngineType_descriptor(), value);
}
inline bool EngineDesc_EngineType_Parse(
    const ::std::string& name, EngineDesc_EngineType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EngineDesc_EngineType>(
    EngineDesc_EngineType_descriptor(), name, value);
}
// ===================================================================

class AITensorParaDescription : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hiai.AITensorParaDescription) */ {
 public:
  AITensorParaDescription();
  virtual ~AITensorParaDescription();

  AITensorParaDescription(const AITensorParaDescription& from);

  inline AITensorParaDescription& operator=(const AITensorParaDescription& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AITensorParaDescription(AITensorParaDescription&& from) noexcept
    : AITensorParaDescription() {
    *this = ::std::move(from);
  }

  inline AITensorParaDescription& operator=(AITensorParaDescription&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AITensorParaDescription& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AITensorParaDescription* internal_default_instance() {
    return reinterpret_cast<const AITensorParaDescription*>(
               &_AITensorParaDescription_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(AITensorParaDescription* other);
  friend void swap(AITensorParaDescription& a, AITensorParaDescription& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AITensorParaDescription* New() const PROTOBUF_FINAL { return New(NULL); }

  AITensorParaDescription* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AITensorParaDescription& from);
  void MergeFrom(const AITensorParaDescription& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AITensorParaDescription* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .hiai.AITensorParaDescription sub_paras = 5;
  int sub_paras_size() const;
  void clear_sub_paras();
  static const int kSubParasFieldNumber = 5;
  const ::hiai::AITensorParaDescription& sub_paras(int index) const;
  ::hiai::AITensorParaDescription* mutable_sub_paras(int index);
  ::hiai::AITensorParaDescription* add_sub_paras();
  ::google::protobuf::RepeatedPtrField< ::hiai::AITensorParaDescription >*
      mutable_sub_paras();
  const ::google::protobuf::RepeatedPtrField< ::hiai::AITensorParaDescription >&
      sub_paras() const;

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string type = 2;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // string value = 3;
  void clear_value();
  static const int kValueFieldNumber = 3;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // string desc = 4;
  void clear_desc();
  static const int kDescFieldNumber = 4;
  const ::std::string& desc() const;
  void set_desc(const ::std::string& value);
  #if LANG_CXX11
  void set_desc(::std::string&& value);
  #endif
  void set_desc(const char* value);
  void set_desc(const char* value, size_t size);
  ::std::string* mutable_desc();
  ::std::string* release_desc();
  void set_allocated_desc(::std::string* desc);

  // @@protoc_insertion_point(class_scope:hiai.AITensorParaDescription)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::hiai::AITensorParaDescription > sub_paras_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  ::google::protobuf::internal::ArenaStringPtr desc_;
  mutable int _cached_size_;
  friend struct ::protobuf_ai_5ftypes_2eproto::TableStruct;
  friend void ::protobuf_ai_5ftypes_2eproto::InitDefaultsAITensorParaDescriptionImpl();
};
// -------------------------------------------------------------------

class AITensorDescription : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hiai.AITensorDescription) */ {
 public:
  AITensorDescription();
  virtual ~AITensorDescription();

  AITensorDescription(const AITensorDescription& from);

  inline AITensorDescription& operator=(const AITensorDescription& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AITensorDescription(AITensorDescription&& from) noexcept
    : AITensorDescription() {
    *this = ::std::move(from);
  }

  inline AITensorDescription& operator=(AITensorDescription&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AITensorDescription& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AITensorDescription* internal_default_instance() {
    return reinterpret_cast<const AITensorDescription*>(
               &_AITensorDescription_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(AITensorDescription* other);
  friend void swap(AITensorDescription& a, AITensorDescription& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AITensorDescription* New() const PROTOBUF_FINAL { return New(NULL); }

  AITensorDescription* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AITensorDescription& from);
  void MergeFrom(const AITensorDescription& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AITensorDescription* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string compatible_type = 3;
  int compatible_type_size() const;
  void clear_compatible_type();
  static const int kCompatibleTypeFieldNumber = 3;
  const ::std::string& compatible_type(int index) const;
  ::std::string* mutable_compatible_type(int index);
  void set_compatible_type(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_compatible_type(int index, ::std::string&& value);
  #endif
  void set_compatible_type(int index, const char* value);
  void set_compatible_type(int index, const char* value, size_t size);
  ::std::string* add_compatible_type();
  void add_compatible_type(const ::std::string& value);
  #if LANG_CXX11
  void add_compatible_type(::std::string&& value);
  #endif
  void add_compatible_type(const char* value);
  void add_compatible_type(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& compatible_type() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_compatible_type();

  // repeated .hiai.AITensorParaDescription paras = 4;
  int paras_size() const;
  void clear_paras();
  static const int kParasFieldNumber = 4;
  const ::hiai::AITensorParaDescription& paras(int index) const;
  ::hiai::AITensorParaDescription* mutable_paras(int index);
  ::hiai::AITensorParaDescription* add_paras();
  ::google::protobuf::RepeatedPtrField< ::hiai::AITensorParaDescription >*
      mutable_paras();
  const ::google::protobuf::RepeatedPtrField< ::hiai::AITensorParaDescription >&
      paras() const;

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string type = 2;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // @@protoc_insertion_point(class_scope:hiai.AITensorDescription)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> compatible_type_;
  ::google::protobuf::RepeatedPtrField< ::hiai::AITensorParaDescription > paras_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  mutable int _cached_size_;
  friend struct ::protobuf_ai_5ftypes_2eproto::TableStruct;
  friend void ::protobuf_ai_5ftypes_2eproto::InitDefaultsAITensorDescriptionImpl();
};
// -------------------------------------------------------------------

class AITensorDescriptionList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hiai.AITensorDescriptionList) */ {
 public:
  AITensorDescriptionList();
  virtual ~AITensorDescriptionList();

  AITensorDescriptionList(const AITensorDescriptionList& from);

  inline AITensorDescriptionList& operator=(const AITensorDescriptionList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AITensorDescriptionList(AITensorDescriptionList&& from) noexcept
    : AITensorDescriptionList() {
    *this = ::std::move(from);
  }

  inline AITensorDescriptionList& operator=(AITensorDescriptionList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AITensorDescriptionList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AITensorDescriptionList* internal_default_instance() {
    return reinterpret_cast<const AITensorDescriptionList*>(
               &_AITensorDescriptionList_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(AITensorDescriptionList* other);
  friend void swap(AITensorDescriptionList& a, AITensorDescriptionList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AITensorDescriptionList* New() const PROTOBUF_FINAL { return New(NULL); }

  AITensorDescriptionList* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AITensorDescriptionList& from);
  void MergeFrom(const AITensorDescriptionList& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AITensorDescriptionList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .hiai.AITensorDescription tensor_descs = 1;
  int tensor_descs_size() const;
  void clear_tensor_descs();
  static const int kTensorDescsFieldNumber = 1;
  const ::hiai::AITensorDescription& tensor_descs(int index) const;
  ::hiai::AITensorDescription* mutable_tensor_descs(int index);
  ::hiai::AITensorDescription* add_tensor_descs();
  ::google::protobuf::RepeatedPtrField< ::hiai::AITensorDescription >*
      mutable_tensor_descs();
  const ::google::protobuf::RepeatedPtrField< ::hiai::AITensorDescription >&
      tensor_descs() const;

  // @@protoc_insertion_point(class_scope:hiai.AITensorDescriptionList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::hiai::AITensorDescription > tensor_descs_;
  mutable int _cached_size_;
  friend struct ::protobuf_ai_5ftypes_2eproto::TableStruct;
  friend void ::protobuf_ai_5ftypes_2eproto::InitDefaultsAITensorDescriptionListImpl();
};
// -------------------------------------------------------------------

class AIConfigItem : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hiai.AIConfigItem) */ {
 public:
  AIConfigItem();
  virtual ~AIConfigItem();

  AIConfigItem(const AIConfigItem& from);

  inline AIConfigItem& operator=(const AIConfigItem& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AIConfigItem(AIConfigItem&& from) noexcept
    : AIConfigItem() {
    *this = ::std::move(from);
  }

  inline AIConfigItem& operator=(AIConfigItem&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AIConfigItem& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AIConfigItem* internal_default_instance() {
    return reinterpret_cast<const AIConfigItem*>(
               &_AIConfigItem_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(AIConfigItem* other);
  friend void swap(AIConfigItem& a, AIConfigItem& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AIConfigItem* New() const PROTOBUF_FINAL { return New(NULL); }

  AIConfigItem* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AIConfigItem& from);
  void MergeFrom(const AIConfigItem& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AIConfigItem* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .hiai.AIConfigItem sub_items = 3;
  int sub_items_size() const;
  void clear_sub_items();
  static const int kSubItemsFieldNumber = 3;
  const ::hiai::AIConfigItem& sub_items(int index) const;
  ::hiai::AIConfigItem* mutable_sub_items(int index);
  ::hiai::AIConfigItem* add_sub_items();
  ::google::protobuf::RepeatedPtrField< ::hiai::AIConfigItem >*
      mutable_sub_items();
  const ::google::protobuf::RepeatedPtrField< ::hiai::AIConfigItem >&
      sub_items() const;

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string value = 2;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:hiai.AIConfigItem)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::hiai::AIConfigItem > sub_items_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  mutable int _cached_size_;
  friend struct ::protobuf_ai_5ftypes_2eproto::TableStruct;
  friend void ::protobuf_ai_5ftypes_2eproto::InitDefaultsAIConfigItemImpl();
};
// -------------------------------------------------------------------

class AIConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hiai.AIConfig) */ {
 public:
  AIConfig();
  virtual ~AIConfig();

  AIConfig(const AIConfig& from);

  inline AIConfig& operator=(const AIConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AIConfig(AIConfig&& from) noexcept
    : AIConfig() {
    *this = ::std::move(from);
  }

  inline AIConfig& operator=(AIConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AIConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AIConfig* internal_default_instance() {
    return reinterpret_cast<const AIConfig*>(
               &_AIConfig_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(AIConfig* other);
  friend void swap(AIConfig& a, AIConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AIConfig* New() const PROTOBUF_FINAL { return New(NULL); }

  AIConfig* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AIConfig& from);
  void MergeFrom(const AIConfig& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AIConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .hiai.AIConfigItem items = 1;
  int items_size() const;
  void clear_items();
  static const int kItemsFieldNumber = 1;
  const ::hiai::AIConfigItem& items(int index) const;
  ::hiai::AIConfigItem* mutable_items(int index);
  ::hiai::AIConfigItem* add_items();
  ::google::protobuf::RepeatedPtrField< ::hiai::AIConfigItem >*
      mutable_items();
  const ::google::protobuf::RepeatedPtrField< ::hiai::AIConfigItem >&
      items() const;

  // @@protoc_insertion_point(class_scope:hiai.AIConfig)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::hiai::AIConfigItem > items_;
  mutable int _cached_size_;
  friend struct ::protobuf_ai_5ftypes_2eproto::TableStruct;
  friend void ::protobuf_ai_5ftypes_2eproto::InitDefaultsAIConfigImpl();
};
// -------------------------------------------------------------------

class AIModelDescription : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hiai.AIModelDescription) */ {
 public:
  AIModelDescription();
  virtual ~AIModelDescription();

  AIModelDescription(const AIModelDescription& from);

  inline AIModelDescription& operator=(const AIModelDescription& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AIModelDescription(AIModelDescription&& from) noexcept
    : AIModelDescription() {
    *this = ::std::move(from);
  }

  inline AIModelDescription& operator=(AIModelDescription&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AIModelDescription& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AIModelDescription* internal_default_instance() {
    return reinterpret_cast<const AIModelDescription*>(
               &_AIModelDescription_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(AIModelDescription* other);
  friend void swap(AIModelDescription& a, AIModelDescription& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AIModelDescription* New() const PROTOBUF_FINAL { return New(NULL); }

  AIModelDescription* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AIModelDescription& from);
  void MergeFrom(const AIModelDescription& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AIModelDescription* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef AIModelDescription_Frequency Frequency;
  static const Frequency UNSET =
    AIModelDescription_Frequency_UNSET;
  static const Frequency LOW =
    AIModelDescription_Frequency_LOW;
  static const Frequency MEDIUM =
    AIModelDescription_Frequency_MEDIUM;
  static const Frequency HIGH =
    AIModelDescription_Frequency_HIGH;
  static inline bool Frequency_IsValid(int value) {
    return AIModelDescription_Frequency_IsValid(value);
  }
  static const Frequency Frequency_MIN =
    AIModelDescription_Frequency_Frequency_MIN;
  static const Frequency Frequency_MAX =
    AIModelDescription_Frequency_Frequency_MAX;
  static const int Frequency_ARRAYSIZE =
    AIModelDescription_Frequency_Frequency_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Frequency_descriptor() {
    return AIModelDescription_Frequency_descriptor();
  }
  static inline const ::std::string& Frequency_Name(Frequency value) {
    return AIModelDescription_Frequency_Name(value);
  }
  static inline bool Frequency_Parse(const ::std::string& name,
      Frequency* value) {
    return AIModelDescription_Frequency_Parse(name, value);
  }

  typedef AIModelDescription_DeviceType DeviceType;
  static const DeviceType NPU =
    AIModelDescription_DeviceType_NPU;
  static const DeviceType IPU =
    AIModelDescription_DeviceType_IPU;
  static const DeviceType MLU =
    AIModelDescription_DeviceType_MLU;
  static const DeviceType CPU =
    AIModelDescription_DeviceType_CPU;
  static const DeviceType NONE =
    AIModelDescription_DeviceType_NONE;
  static inline bool DeviceType_IsValid(int value) {
    return AIModelDescription_DeviceType_IsValid(value);
  }
  static const DeviceType DeviceType_MIN =
    AIModelDescription_DeviceType_DeviceType_MIN;
  static const DeviceType DeviceType_MAX =
    AIModelDescription_DeviceType_DeviceType_MAX;
  static const int DeviceType_ARRAYSIZE =
    AIModelDescription_DeviceType_DeviceType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  DeviceType_descriptor() {
    return AIModelDescription_DeviceType_descriptor();
  }
  static inline const ::std::string& DeviceType_Name(DeviceType value) {
    return AIModelDescription_DeviceType_Name(value);
  }
  static inline bool DeviceType_Parse(const ::std::string& name,
      DeviceType* value) {
    return AIModelDescription_DeviceType_Parse(name, value);
  }

  typedef AIModelDescription_Framework Framework;
  static const Framework OFFLINE =
    AIModelDescription_Framework_OFFLINE;
  static const Framework CAFFE =
    AIModelDescription_Framework_CAFFE;
  static const Framework TENSORFLOW =
    AIModelDescription_Framework_TENSORFLOW;
  static inline bool Framework_IsValid(int value) {
    return AIModelDescription_Framework_IsValid(value);
  }
  static const Framework Framework_MIN =
    AIModelDescription_Framework_Framework_MIN;
  static const Framework Framework_MAX =
    AIModelDescription_Framework_Framework_MAX;
  static const int Framework_ARRAYSIZE =
    AIModelDescription_Framework_Framework_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Framework_descriptor() {
    return AIModelDescription_Framework_descriptor();
  }
  static inline const ::std::string& Framework_Name(Framework value) {
    return AIModelDescription_Framework_Name(value);
  }
  static inline bool Framework_Parse(const ::std::string& name,
      Framework* value) {
    return AIModelDescription_Framework_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated string sub_path = 6;
  int sub_path_size() const;
  void clear_sub_path();
  static const int kSubPathFieldNumber = 6;
  const ::std::string& sub_path(int index) const;
  ::std::string* mutable_sub_path(int index);
  void set_sub_path(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_sub_path(int index, ::std::string&& value);
  #endif
  void set_sub_path(int index, const char* value);
  void set_sub_path(int index, const char* value, size_t size);
  ::std::string* add_sub_path();
  void add_sub_path(const ::std::string& value);
  #if LANG_CXX11
  void add_sub_path(::std::string&& value);
  #endif
  void add_sub_path(const char* value);
  void add_sub_path(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& sub_path() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_sub_path();

  // repeated string sub_key = 8;
  int sub_key_size() const;
  void clear_sub_key();
  static const int kSubKeyFieldNumber = 8;
  const ::std::string& sub_key(int index) const;
  ::std::string* mutable_sub_key(int index);
  void set_sub_key(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_sub_key(int index, ::std::string&& value);
  #endif
  void set_sub_key(int index, const char* value);
  void set_sub_key(int index, const char* value, size_t size);
  ::std::string* add_sub_key();
  void add_sub_key(const ::std::string& value);
  #if LANG_CXX11
  void add_sub_key(::std::string&& value);
  #endif
  void add_sub_key(const char* value);
  void add_sub_key(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& sub_key() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_sub_key();

  // repeated .hiai.AITensorDescription inputs = 12;
  int inputs_size() const;
  void clear_inputs();
  static const int kInputsFieldNumber = 12;
  const ::hiai::AITensorDescription& inputs(int index) const;
  ::hiai::AITensorDescription* mutable_inputs(int index);
  ::hiai::AITensorDescription* add_inputs();
  ::google::protobuf::RepeatedPtrField< ::hiai::AITensorDescription >*
      mutable_inputs();
  const ::google::protobuf::RepeatedPtrField< ::hiai::AITensorDescription >&
      inputs() const;

  // repeated .hiai.AITensorDescription outputs = 13;
  int outputs_size() const;
  void clear_outputs();
  static const int kOutputsFieldNumber = 13;
  const ::hiai::AITensorDescription& outputs(int index) const;
  ::hiai::AITensorDescription* mutable_outputs(int index);
  ::hiai::AITensorDescription* add_outputs();
  ::google::protobuf::RepeatedPtrField< ::hiai::AITensorDescription >*
      mutable_outputs();
  const ::google::protobuf::RepeatedPtrField< ::hiai::AITensorDescription >&
      outputs() const;

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string version = 3;
  void clear_version();
  static const int kVersionFieldNumber = 3;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // string path = 5;
  void clear_path();
  static const int kPathFieldNumber = 5;
  const ::std::string& path() const;
  void set_path(const ::std::string& value);
  #if LANG_CXX11
  void set_path(::std::string&& value);
  #endif
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  ::std::string* mutable_path();
  ::std::string* release_path();
  void set_allocated_path(::std::string* path);

  // string key = 7;
  void clear_key();
  static const int kKeyFieldNumber = 7;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // bytes data = 100;
  void clear_data();
  static const int kDataFieldNumber = 100;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // int32 type = 2;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::google::protobuf::int32 type() const;
  void set_type(::google::protobuf::int32 value);

  // int32 size = 4;
  void clear_size();
  static const int kSizeFieldNumber = 4;
  ::google::protobuf::int32 size() const;
  void set_size(::google::protobuf::int32 value);

  // .hiai.AIModelDescription.Frequency frequency = 9;
  void clear_frequency();
  static const int kFrequencyFieldNumber = 9;
  ::hiai::AIModelDescription_Frequency frequency() const;
  void set_frequency(::hiai::AIModelDescription_Frequency value);

  // .hiai.AIModelDescription.DeviceType device_type = 10;
  void clear_device_type();
  static const int kDeviceTypeFieldNumber = 10;
  ::hiai::AIModelDescription_DeviceType device_type() const;
  void set_device_type(::hiai::AIModelDescription_DeviceType value);

  // .hiai.AIModelDescription.Framework framework = 11;
  void clear_framework();
  static const int kFrameworkFieldNumber = 11;
  ::hiai::AIModelDescription_Framework framework() const;
  void set_framework(::hiai::AIModelDescription_Framework value);

  // @@protoc_insertion_point(class_scope:hiai.AIModelDescription)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> sub_path_;
  ::google::protobuf::RepeatedPtrField< ::std::string> sub_key_;
  ::google::protobuf::RepeatedPtrField< ::hiai::AITensorDescription > inputs_;
  ::google::protobuf::RepeatedPtrField< ::hiai::AITensorDescription > outputs_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  ::google::protobuf::internal::ArenaStringPtr path_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 size_;
  int frequency_;
  int device_type_;
  int framework_;
  mutable int _cached_size_;
  friend struct ::protobuf_ai_5ftypes_2eproto::TableStruct;
  friend void ::protobuf_ai_5ftypes_2eproto::InitDefaultsAIModelDescriptionImpl();
};
// -------------------------------------------------------------------

class AINNNodeDescription : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hiai.AINNNodeDescription) */ {
 public:
  AINNNodeDescription();
  virtual ~AINNNodeDescription();

  AINNNodeDescription(const AINNNodeDescription& from);

  inline AINNNodeDescription& operator=(const AINNNodeDescription& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AINNNodeDescription(AINNNodeDescription&& from) noexcept
    : AINNNodeDescription() {
    *this = ::std::move(from);
  }

  inline AINNNodeDescription& operator=(AINNNodeDescription&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AINNNodeDescription& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AINNNodeDescription* internal_default_instance() {
    return reinterpret_cast<const AINNNodeDescription*>(
               &_AINNNodeDescription_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(AINNNodeDescription* other);
  friend void swap(AINNNodeDescription& a, AINNNodeDescription& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AINNNodeDescription* New() const PROTOBUF_FINAL { return New(NULL); }

  AINNNodeDescription* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AINNNodeDescription& from);
  void MergeFrom(const AINNNodeDescription& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AINNNodeDescription* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .hiai.AIModelDescription model_list = 5;
  int model_list_size() const;
  void clear_model_list();
  static const int kModelListFieldNumber = 5;
  const ::hiai::AIModelDescription& model_list(int index) const;
  ::hiai::AIModelDescription* mutable_model_list(int index);
  ::hiai::AIModelDescription* add_model_list();
  ::google::protobuf::RepeatedPtrField< ::hiai::AIModelDescription >*
      mutable_model_list();
  const ::google::protobuf::RepeatedPtrField< ::hiai::AIModelDescription >&
      model_list() const;

  // repeated .hiai.AITensorDescription inputs = 6;
  int inputs_size() const;
  void clear_inputs();
  static const int kInputsFieldNumber = 6;
  const ::hiai::AITensorDescription& inputs(int index) const;
  ::hiai::AITensorDescription* mutable_inputs(int index);
  ::hiai::AITensorDescription* add_inputs();
  ::google::protobuf::RepeatedPtrField< ::hiai::AITensorDescription >*
      mutable_inputs();
  const ::google::protobuf::RepeatedPtrField< ::hiai::AITensorDescription >&
      inputs() const;

  // repeated .hiai.AITensorDescription outputs = 7;
  int outputs_size() const;
  void clear_outputs();
  static const int kOutputsFieldNumber = 7;
  const ::hiai::AITensorDescription& outputs(int index) const;
  ::hiai::AITensorDescription* mutable_outputs(int index);
  ::hiai::AITensorDescription* add_outputs();
  ::google::protobuf::RepeatedPtrField< ::hiai::AITensorDescription >*
      mutable_outputs();
  const ::google::protobuf::RepeatedPtrField< ::hiai::AITensorDescription >&
      outputs() const;

  // repeated string ignored_check_aitensor = 9;
  int ignored_check_aitensor_size() const;
  void clear_ignored_check_aitensor();
  static const int kIgnoredCheckAitensorFieldNumber = 9;
  const ::std::string& ignored_check_aitensor(int index) const;
  ::std::string* mutable_ignored_check_aitensor(int index);
  void set_ignored_check_aitensor(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_ignored_check_aitensor(int index, ::std::string&& value);
  #endif
  void set_ignored_check_aitensor(int index, const char* value);
  void set_ignored_check_aitensor(int index, const char* value, size_t size);
  ::std::string* add_ignored_check_aitensor();
  void add_ignored_check_aitensor(const ::std::string& value);
  #if LANG_CXX11
  void add_ignored_check_aitensor(::std::string&& value);
  #endif
  void add_ignored_check_aitensor(const char* value);
  void add_ignored_check_aitensor(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& ignored_check_aitensor() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_ignored_check_aitensor();

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string desc = 2;
  void clear_desc();
  static const int kDescFieldNumber = 2;
  const ::std::string& desc() const;
  void set_desc(const ::std::string& value);
  #if LANG_CXX11
  void set_desc(::std::string&& value);
  #endif
  void set_desc(const char* value);
  void set_desc(const char* value, size_t size);
  ::std::string* mutable_desc();
  ::std::string* release_desc();
  void set_allocated_desc(::std::string* desc);

  // .hiai.AIConfig config = 4;
  bool has_config() const;
  void clear_config();
  static const int kConfigFieldNumber = 4;
  const ::hiai::AIConfig& config() const;
  ::hiai::AIConfig* release_config();
  ::hiai::AIConfig* mutable_config();
  void set_allocated_config(::hiai::AIConfig* config);

  // bool isPreAllocateOutputMem = 3;
  void clear_ispreallocateoutputmem();
  static const int kIsPreAllocateOutputMemFieldNumber = 3;
  bool ispreallocateoutputmem() const;
  void set_ispreallocateoutputmem(bool value);

  // bool need_verify = 8;
  void clear_need_verify();
  static const int kNeedVerifyFieldNumber = 8;
  bool need_verify() const;
  void set_need_verify(bool value);

  // @@protoc_insertion_point(class_scope:hiai.AINNNodeDescription)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::hiai::AIModelDescription > model_list_;
  ::google::protobuf::RepeatedPtrField< ::hiai::AITensorDescription > inputs_;
  ::google::protobuf::RepeatedPtrField< ::hiai::AITensorDescription > outputs_;
  ::google::protobuf::RepeatedPtrField< ::std::string> ignored_check_aitensor_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr desc_;
  ::hiai::AIConfig* config_;
  bool ispreallocateoutputmem_;
  bool need_verify_;
  mutable int _cached_size_;
  friend struct ::protobuf_ai_5ftypes_2eproto::TableStruct;
  friend void ::protobuf_ai_5ftypes_2eproto::InitDefaultsAINNNodeDescriptionImpl();
};
// -------------------------------------------------------------------

class AINNNodeDescriptionList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hiai.AINNNodeDescriptionList) */ {
 public:
  AINNNodeDescriptionList();
  virtual ~AINNNodeDescriptionList();

  AINNNodeDescriptionList(const AINNNodeDescriptionList& from);

  inline AINNNodeDescriptionList& operator=(const AINNNodeDescriptionList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AINNNodeDescriptionList(AINNNodeDescriptionList&& from) noexcept
    : AINNNodeDescriptionList() {
    *this = ::std::move(from);
  }

  inline AINNNodeDescriptionList& operator=(AINNNodeDescriptionList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AINNNodeDescriptionList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AINNNodeDescriptionList* internal_default_instance() {
    return reinterpret_cast<const AINNNodeDescriptionList*>(
               &_AINNNodeDescriptionList_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(AINNNodeDescriptionList* other);
  friend void swap(AINNNodeDescriptionList& a, AINNNodeDescriptionList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AINNNodeDescriptionList* New() const PROTOBUF_FINAL { return New(NULL); }

  AINNNodeDescriptionList* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AINNNodeDescriptionList& from);
  void MergeFrom(const AINNNodeDescriptionList& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AINNNodeDescriptionList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .hiai.AINNNodeDescription nnnode_descs = 1;
  int nnnode_descs_size() const;
  void clear_nnnode_descs();
  static const int kNnnodeDescsFieldNumber = 1;
  const ::hiai::AINNNodeDescription& nnnode_descs(int index) const;
  ::hiai::AINNNodeDescription* mutable_nnnode_descs(int index);
  ::hiai::AINNNodeDescription* add_nnnode_descs();
  ::google::protobuf::RepeatedPtrField< ::hiai::AINNNodeDescription >*
      mutable_nnnode_descs();
  const ::google::protobuf::RepeatedPtrField< ::hiai::AINNNodeDescription >&
      nnnode_descs() const;

  // @@protoc_insertion_point(class_scope:hiai.AINNNodeDescriptionList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::hiai::AINNNodeDescription > nnnode_descs_;
  mutable int _cached_size_;
  friend struct ::protobuf_ai_5ftypes_2eproto::TableStruct;
  friend void ::protobuf_ai_5ftypes_2eproto::InitDefaultsAINNNodeDescriptionListImpl();
};
// -------------------------------------------------------------------

class AIAPIDescription : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hiai.AIAPIDescription) */ {
 public:
  AIAPIDescription();
  virtual ~AIAPIDescription();

  AIAPIDescription(const AIAPIDescription& from);

  inline AIAPIDescription& operator=(const AIAPIDescription& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AIAPIDescription(AIAPIDescription&& from) noexcept
    : AIAPIDescription() {
    *this = ::std::move(from);
  }

  inline AIAPIDescription& operator=(AIAPIDescription&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AIAPIDescription& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AIAPIDescription* internal_default_instance() {
    return reinterpret_cast<const AIAPIDescription*>(
               &_AIAPIDescription_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(AIAPIDescription* other);
  friend void swap(AIAPIDescription& a, AIAPIDescription& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AIAPIDescription* New() const PROTOBUF_FINAL { return New(NULL); }

  AIAPIDescription* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AIAPIDescription& from);
  void MergeFrom(const AIAPIDescription& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AIAPIDescription* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .hiai.AITensorDescription inputs = 5;
  int inputs_size() const;
  void clear_inputs();
  static const int kInputsFieldNumber = 5;
  const ::hiai::AITensorDescription& inputs(int index) const;
  ::hiai::AITensorDescription* mutable_inputs(int index);
  ::hiai::AITensorDescription* add_inputs();
  ::google::protobuf::RepeatedPtrField< ::hiai::AITensorDescription >*
      mutable_inputs();
  const ::google::protobuf::RepeatedPtrField< ::hiai::AITensorDescription >&
      inputs() const;

  // repeated .hiai.AITensorDescription outputs = 6;
  int outputs_size() const;
  void clear_outputs();
  static const int kOutputsFieldNumber = 6;
  const ::hiai::AITensorDescription& outputs(int index) const;
  ::hiai::AITensorDescription* mutable_outputs(int index);
  ::hiai::AITensorDescription* add_outputs();
  ::google::protobuf::RepeatedPtrField< ::hiai::AITensorDescription >*
      mutable_outputs();
  const ::google::protobuf::RepeatedPtrField< ::hiai::AITensorDescription >&
      outputs() const;

  // repeated string ignored_check_aitensor = 8;
  int ignored_check_aitensor_size() const;
  void clear_ignored_check_aitensor();
  static const int kIgnoredCheckAitensorFieldNumber = 8;
  const ::std::string& ignored_check_aitensor(int index) const;
  ::std::string* mutable_ignored_check_aitensor(int index);
  void set_ignored_check_aitensor(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_ignored_check_aitensor(int index, ::std::string&& value);
  #endif
  void set_ignored_check_aitensor(int index, const char* value);
  void set_ignored_check_aitensor(int index, const char* value, size_t size);
  ::std::string* add_ignored_check_aitensor();
  void add_ignored_check_aitensor(const ::std::string& value);
  #if LANG_CXX11
  void add_ignored_check_aitensor(::std::string&& value);
  #endif
  void add_ignored_check_aitensor(const char* value);
  void add_ignored_check_aitensor(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& ignored_check_aitensor() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_ignored_check_aitensor();

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string desc = 2;
  void clear_desc();
  static const int kDescFieldNumber = 2;
  const ::std::string& desc() const;
  void set_desc(const ::std::string& value);
  #if LANG_CXX11
  void set_desc(::std::string&& value);
  #endif
  void set_desc(const char* value);
  void set_desc(const char* value, size_t size);
  ::std::string* mutable_desc();
  ::std::string* release_desc();
  void set_allocated_desc(::std::string* desc);

  // .hiai.AIConfig config = 4;
  bool has_config() const;
  void clear_config();
  static const int kConfigFieldNumber = 4;
  const ::hiai::AIConfig& config() const;
  ::hiai::AIConfig* release_config();
  ::hiai::AIConfig* mutable_config();
  void set_allocated_config(::hiai::AIConfig* config);

  // bool isPreAllocateOutputMem = 3;
  void clear_ispreallocateoutputmem();
  static const int kIsPreAllocateOutputMemFieldNumber = 3;
  bool ispreallocateoutputmem() const;
  void set_ispreallocateoutputmem(bool value);

  // bool need_verify = 7;
  void clear_need_verify();
  static const int kNeedVerifyFieldNumber = 7;
  bool need_verify() const;
  void set_need_verify(bool value);

  // @@protoc_insertion_point(class_scope:hiai.AIAPIDescription)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::hiai::AITensorDescription > inputs_;
  ::google::protobuf::RepeatedPtrField< ::hiai::AITensorDescription > outputs_;
  ::google::protobuf::RepeatedPtrField< ::std::string> ignored_check_aitensor_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr desc_;
  ::hiai::AIConfig* config_;
  bool ispreallocateoutputmem_;
  bool need_verify_;
  mutable int _cached_size_;
  friend struct ::protobuf_ai_5ftypes_2eproto::TableStruct;
  friend void ::protobuf_ai_5ftypes_2eproto::InitDefaultsAIAPIDescriptionImpl();
};
// -------------------------------------------------------------------

class AIAPIDescriptionList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hiai.AIAPIDescriptionList) */ {
 public:
  AIAPIDescriptionList();
  virtual ~AIAPIDescriptionList();

  AIAPIDescriptionList(const AIAPIDescriptionList& from);

  inline AIAPIDescriptionList& operator=(const AIAPIDescriptionList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AIAPIDescriptionList(AIAPIDescriptionList&& from) noexcept
    : AIAPIDescriptionList() {
    *this = ::std::move(from);
  }

  inline AIAPIDescriptionList& operator=(AIAPIDescriptionList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AIAPIDescriptionList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AIAPIDescriptionList* internal_default_instance() {
    return reinterpret_cast<const AIAPIDescriptionList*>(
               &_AIAPIDescriptionList_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(AIAPIDescriptionList* other);
  friend void swap(AIAPIDescriptionList& a, AIAPIDescriptionList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AIAPIDescriptionList* New() const PROTOBUF_FINAL { return New(NULL); }

  AIAPIDescriptionList* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AIAPIDescriptionList& from);
  void MergeFrom(const AIAPIDescriptionList& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AIAPIDescriptionList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .hiai.AIAPIDescription api_descs = 1;
  int api_descs_size() const;
  void clear_api_descs();
  static const int kApiDescsFieldNumber = 1;
  const ::hiai::AIAPIDescription& api_descs(int index) const;
  ::hiai::AIAPIDescription* mutable_api_descs(int index);
  ::hiai::AIAPIDescription* add_api_descs();
  ::google::protobuf::RepeatedPtrField< ::hiai::AIAPIDescription >*
      mutable_api_descs();
  const ::google::protobuf::RepeatedPtrField< ::hiai::AIAPIDescription >&
      api_descs() const;

  // @@protoc_insertion_point(class_scope:hiai.AIAPIDescriptionList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::hiai::AIAPIDescription > api_descs_;
  mutable int _cached_size_;
  friend struct ::protobuf_ai_5ftypes_2eproto::TableStruct;
  friend void ::protobuf_ai_5ftypes_2eproto::InitDefaultsAIAPIDescriptionListImpl();
};
// -------------------------------------------------------------------

class AIOPDescription : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hiai.AIOPDescription) */ {
 public:
  AIOPDescription();
  virtual ~AIOPDescription();

  AIOPDescription(const AIOPDescription& from);

  inline AIOPDescription& operator=(const AIOPDescription& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AIOPDescription(AIOPDescription&& from) noexcept
    : AIOPDescription() {
    *this = ::std::move(from);
  }

  inline AIOPDescription& operator=(AIOPDescription&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AIOPDescription& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AIOPDescription* internal_default_instance() {
    return reinterpret_cast<const AIOPDescription*>(
               &_AIOPDescription_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(AIOPDescription* other);
  friend void swap(AIOPDescription& a, AIOPDescription& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AIOPDescription* New() const PROTOBUF_FINAL { return New(NULL); }

  AIOPDescription* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AIOPDescription& from);
  void MergeFrom(const AIOPDescription& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AIOPDescription* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef AIOPDescription_OP_Type OP_Type;
  static const OP_Type AI_API =
    AIOPDescription_OP_Type_AI_API;
  static const OP_Type AI_NNNODE =
    AIOPDescription_OP_Type_AI_NNNODE;
  static inline bool OP_Type_IsValid(int value) {
    return AIOPDescription_OP_Type_IsValid(value);
  }
  static const OP_Type OP_Type_MIN =
    AIOPDescription_OP_Type_OP_Type_MIN;
  static const OP_Type OP_Type_MAX =
    AIOPDescription_OP_Type_OP_Type_MAX;
  static const int OP_Type_ARRAYSIZE =
    AIOPDescription_OP_Type_OP_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  OP_Type_descriptor() {
    return AIOPDescription_OP_Type_descriptor();
  }
  static inline const ::std::string& OP_Type_Name(OP_Type value) {
    return AIOPDescription_OP_Type_Name(value);
  }
  static inline bool OP_Type_Parse(const ::std::string& name,
      OP_Type* value) {
    return AIOPDescription_OP_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .hiai.AINNNodeDescription nnnode_desc = 2;
  bool has_nnnode_desc() const;
  void clear_nnnode_desc();
  static const int kNnnodeDescFieldNumber = 2;
  const ::hiai::AINNNodeDescription& nnnode_desc() const;
  ::hiai::AINNNodeDescription* release_nnnode_desc();
  ::hiai::AINNNodeDescription* mutable_nnnode_desc();
  void set_allocated_nnnode_desc(::hiai::AINNNodeDescription* nnnode_desc);

  // .hiai.AIAPIDescription api_desc = 3;
  bool has_api_desc() const;
  void clear_api_desc();
  static const int kApiDescFieldNumber = 3;
  const ::hiai::AIAPIDescription& api_desc() const;
  ::hiai::AIAPIDescription* release_api_desc();
  ::hiai::AIAPIDescription* mutable_api_desc();
  void set_allocated_api_desc(::hiai::AIAPIDescription* api_desc);

  // .hiai.AIOPDescription.OP_Type type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::hiai::AIOPDescription_OP_Type type() const;
  void set_type(::hiai::AIOPDescription_OP_Type value);

  // @@protoc_insertion_point(class_scope:hiai.AIOPDescription)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::hiai::AINNNodeDescription* nnnode_desc_;
  ::hiai::AIAPIDescription* api_desc_;
  int type_;
  mutable int _cached_size_;
  friend struct ::protobuf_ai_5ftypes_2eproto::TableStruct;
  friend void ::protobuf_ai_5ftypes_2eproto::InitDefaultsAIOPDescriptionImpl();
};
// -------------------------------------------------------------------

class AIOPDescriptionList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hiai.AIOPDescriptionList) */ {
 public:
  AIOPDescriptionList();
  virtual ~AIOPDescriptionList();

  AIOPDescriptionList(const AIOPDescriptionList& from);

  inline AIOPDescriptionList& operator=(const AIOPDescriptionList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AIOPDescriptionList(AIOPDescriptionList&& from) noexcept
    : AIOPDescriptionList() {
    *this = ::std::move(from);
  }

  inline AIOPDescriptionList& operator=(AIOPDescriptionList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AIOPDescriptionList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AIOPDescriptionList* internal_default_instance() {
    return reinterpret_cast<const AIOPDescriptionList*>(
               &_AIOPDescriptionList_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(AIOPDescriptionList* other);
  friend void swap(AIOPDescriptionList& a, AIOPDescriptionList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AIOPDescriptionList* New() const PROTOBUF_FINAL { return New(NULL); }

  AIOPDescriptionList* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AIOPDescriptionList& from);
  void MergeFrom(const AIOPDescriptionList& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AIOPDescriptionList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .hiai.AIOPDescription op_descs = 1;
  int op_descs_size() const;
  void clear_op_descs();
  static const int kOpDescsFieldNumber = 1;
  const ::hiai::AIOPDescription& op_descs(int index) const;
  ::hiai::AIOPDescription* mutable_op_descs(int index);
  ::hiai::AIOPDescription* add_op_descs();
  ::google::protobuf::RepeatedPtrField< ::hiai::AIOPDescription >*
      mutable_op_descs();
  const ::google::protobuf::RepeatedPtrField< ::hiai::AIOPDescription >&
      op_descs() const;

  // @@protoc_insertion_point(class_scope:hiai.AIOPDescriptionList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::hiai::AIOPDescription > op_descs_;
  mutable int _cached_size_;
  friend struct ::protobuf_ai_5ftypes_2eproto::TableStruct;
  friend void ::protobuf_ai_5ftypes_2eproto::InitDefaultsAIOPDescriptionListImpl();
};
// -------------------------------------------------------------------

class NodeDesc : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hiai.NodeDesc) */ {
 public:
  NodeDesc();
  virtual ~NodeDesc();

  NodeDesc(const NodeDesc& from);

  inline NodeDesc& operator=(const NodeDesc& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NodeDesc(NodeDesc&& from) noexcept
    : NodeDesc() {
    *this = ::std::move(from);
  }

  inline NodeDesc& operator=(NodeDesc&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const NodeDesc& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NodeDesc* internal_default_instance() {
    return reinterpret_cast<const NodeDesc*>(
               &_NodeDesc_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(NodeDesc* other);
  friend void swap(NodeDesc& a, NodeDesc& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NodeDesc* New() const PROTOBUF_FINAL { return New(NULL); }

  NodeDesc* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const NodeDesc& from);
  void MergeFrom(const NodeDesc& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(NodeDesc* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .hiai.AIModelDescription mode_desc = 3;
  int mode_desc_size() const;
  void clear_mode_desc();
  static const int kModeDescFieldNumber = 3;
  const ::hiai::AIModelDescription& mode_desc(int index) const;
  ::hiai::AIModelDescription* mutable_mode_desc(int index);
  ::hiai::AIModelDescription* add_mode_desc();
  ::google::protobuf::RepeatedPtrField< ::hiai::AIModelDescription >*
      mutable_mode_desc();
  const ::google::protobuf::RepeatedPtrField< ::hiai::AIModelDescription >&
      mode_desc() const;

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // .hiai.AIConfig config = 2;
  bool has_config() const;
  void clear_config();
  static const int kConfigFieldNumber = 2;
  const ::hiai::AIConfig& config() const;
  ::hiai::AIConfig* release_config();
  ::hiai::AIConfig* mutable_config();
  void set_allocated_config(::hiai::AIConfig* config);

  // @@protoc_insertion_point(class_scope:hiai.NodeDesc)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::hiai::AIModelDescription > mode_desc_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::hiai::AIConfig* config_;
  mutable int _cached_size_;
  friend struct ::protobuf_ai_5ftypes_2eproto::TableStruct;
  friend void ::protobuf_ai_5ftypes_2eproto::InitDefaultsNodeDescImpl();
};
// -------------------------------------------------------------------

class EngineDesc : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hiai.EngineDesc) */ {
 public:
  EngineDesc();
  virtual ~EngineDesc();

  EngineDesc(const EngineDesc& from);

  inline EngineDesc& operator=(const EngineDesc& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EngineDesc(EngineDesc&& from) noexcept
    : EngineDesc() {
    *this = ::std::move(from);
  }

  inline EngineDesc& operator=(EngineDesc&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const EngineDesc& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EngineDesc* internal_default_instance() {
    return reinterpret_cast<const EngineDesc*>(
               &_EngineDesc_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void Swap(EngineDesc* other);
  friend void swap(EngineDesc& a, EngineDesc& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EngineDesc* New() const PROTOBUF_FINAL { return New(NULL); }

  EngineDesc* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EngineDesc& from);
  void MergeFrom(const EngineDesc& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EngineDesc* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef EngineDesc_RunSide RunSide;
  static const RunSide DEVICE =
    EngineDesc_RunSide_DEVICE;
  static const RunSide HOST =
    EngineDesc_RunSide_HOST;
  static inline bool RunSide_IsValid(int value) {
    return EngineDesc_RunSide_IsValid(value);
  }
  static const RunSide RunSide_MIN =
    EngineDesc_RunSide_RunSide_MIN;
  static const RunSide RunSide_MAX =
    EngineDesc_RunSide_RunSide_MAX;
  static const int RunSide_ARRAYSIZE =
    EngineDesc_RunSide_RunSide_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RunSide_descriptor() {
    return EngineDesc_RunSide_descriptor();
  }
  static inline const ::std::string& RunSide_Name(RunSide value) {
    return EngineDesc_RunSide_Name(value);
  }
  static inline bool RunSide_Parse(const ::std::string& name,
      RunSide* value) {
    return EngineDesc_RunSide_Parse(name, value);
  }

  typedef EngineDesc_EngineType EngineType;
  static const EngineType NORMAL =
    EngineDesc_EngineType_NORMAL;
  static const EngineType SOURCE =
    EngineDesc_EngineType_SOURCE;
  static const EngineType DEST =
    EngineDesc_EngineType_DEST;
  static inline bool EngineType_IsValid(int value) {
    return EngineDesc_EngineType_IsValid(value);
  }
  static const EngineType EngineType_MIN =
    EngineDesc_EngineType_EngineType_MIN;
  static const EngineType EngineType_MAX =
    EngineDesc_EngineType_EngineType_MAX;
  static const int EngineType_ARRAYSIZE =
    EngineDesc_EngineType_EngineType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EngineType_descriptor() {
    return EngineDesc_EngineType_descriptor();
  }
  static inline const ::std::string& EngineType_Name(EngineType value) {
    return EngineDesc_EngineType_Name(value);
  }
  static inline bool EngineType_Parse(const ::std::string& name,
      EngineType* value) {
    return EngineDesc_EngineType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated string so_name = 4;
  int so_name_size() const;
  void clear_so_name();
  static const int kSoNameFieldNumber = 4;
  const ::std::string& so_name(int index) const;
  ::std::string* mutable_so_name(int index);
  void set_so_name(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_so_name(int index, ::std::string&& value);
  #endif
  void set_so_name(int index, const char* value);
  void set_so_name(int index, const char* value, size_t size);
  ::std::string* add_so_name();
  void add_so_name(const ::std::string& value);
  #if LANG_CXX11
  void add_so_name(::std::string&& value);
  #endif
  void add_so_name(const char* value);
  void add_so_name(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& so_name() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_so_name();

  // repeated uint32 next_node_id = 8;
  int next_node_id_size() const;
  void clear_next_node_id();
  static const int kNextNodeIdFieldNumber = 8;
  ::google::protobuf::uint32 next_node_id(int index) const;
  void set_next_node_id(int index, ::google::protobuf::uint32 value);
  void add_next_node_id(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      next_node_id() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_next_node_id();

  // repeated .hiai.NodeDesc oper = 11;
  int oper_size() const;
  void clear_oper();
  static const int kOperFieldNumber = 11;
  const ::hiai::NodeDesc& oper(int index) const;
  ::hiai::NodeDesc* mutable_oper(int index);
  ::hiai::NodeDesc* add_oper();
  ::google::protobuf::RepeatedPtrField< ::hiai::NodeDesc >*
      mutable_oper();
  const ::google::protobuf::RepeatedPtrField< ::hiai::NodeDesc >&
      oper() const;

  // string name = 3;
  void clear_name();
  static const int kNameFieldNumber = 3;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // uint32 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::uint32 id() const;
  void set_id(::google::protobuf::uint32 value);

  // .hiai.EngineDesc.EngineType type = 2;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::hiai::EngineDesc_EngineType type() const;
  void set_type(::hiai::EngineDesc_EngineType value);

  // .hiai.EngineDesc.RunSide side = 5;
  void clear_side();
  static const int kSideFieldNumber = 5;
  ::hiai::EngineDesc_RunSide side() const;
  void set_side(::hiai::EngineDesc_RunSide value);

  // int32 priority = 6;
  void clear_priority();
  static const int kPriorityFieldNumber = 6;
  ::google::protobuf::int32 priority() const;
  void set_priority(::google::protobuf::int32 value);

  // uint32 instance_cnt = 7;
  void clear_instance_cnt();
  static const int kInstanceCntFieldNumber = 7;
  ::google::protobuf::uint32 instance_cnt() const;
  void set_instance_cnt(::google::protobuf::uint32 value);

  // bool user_input_cb = 9;
  void clear_user_input_cb();
  static const int kUserInputCbFieldNumber = 9;
  bool user_input_cb() const;
  void set_user_input_cb(bool value);

  // bool user_output_cb = 10;
  void clear_user_output_cb();
  static const int kUserOutputCbFieldNumber = 10;
  bool user_output_cb() const;
  void set_user_output_cb(bool value);

  // @@protoc_insertion_point(class_scope:hiai.EngineDesc)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> so_name_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > next_node_id_;
  mutable int _next_node_id_cached_byte_size_;
  ::google::protobuf::RepeatedPtrField< ::hiai::NodeDesc > oper_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::uint32 id_;
  int type_;
  int side_;
  ::google::protobuf::int32 priority_;
  ::google::protobuf::uint32 instance_cnt_;
  bool user_input_cb_;
  bool user_output_cb_;
  mutable int _cached_size_;
  friend struct ::protobuf_ai_5ftypes_2eproto::TableStruct;
  friend void ::protobuf_ai_5ftypes_2eproto::InitDefaultsEngineDescImpl();
};
// -------------------------------------------------------------------

class GraphInitDesc : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hiai.GraphInitDesc) */ {
 public:
  GraphInitDesc();
  virtual ~GraphInitDesc();

  GraphInitDesc(const GraphInitDesc& from);

  inline GraphInitDesc& operator=(const GraphInitDesc& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GraphInitDesc(GraphInitDesc&& from) noexcept
    : GraphInitDesc() {
    *this = ::std::move(from);
  }

  inline GraphInitDesc& operator=(GraphInitDesc&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GraphInitDesc& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GraphInitDesc* internal_default_instance() {
    return reinterpret_cast<const GraphInitDesc*>(
               &_GraphInitDesc_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    14;

  void Swap(GraphInitDesc* other);
  friend void swap(GraphInitDesc& a, GraphInitDesc& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GraphInitDesc* New() const PROTOBUF_FINAL { return New(NULL); }

  GraphInitDesc* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GraphInitDesc& from);
  void MergeFrom(const GraphInitDesc& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GraphInitDesc* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 priority = 1;
  void clear_priority();
  static const int kPriorityFieldNumber = 1;
  ::google::protobuf::int32 priority() const;
  void set_priority(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:hiai.GraphInitDesc)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 priority_;
  mutable int _cached_size_;
  friend struct ::protobuf_ai_5ftypes_2eproto::TableStruct;
  friend void ::protobuf_ai_5ftypes_2eproto::InitDefaultsGraphInitDescImpl();
};
// -------------------------------------------------------------------

class GeneralFileBuffer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hiai.GeneralFileBuffer) */ {
 public:
  GeneralFileBuffer();
  virtual ~GeneralFileBuffer();

  GeneralFileBuffer(const GeneralFileBuffer& from);

  inline GeneralFileBuffer& operator=(const GeneralFileBuffer& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GeneralFileBuffer(GeneralFileBuffer&& from) noexcept
    : GeneralFileBuffer() {
    *this = ::std::move(from);
  }

  inline GeneralFileBuffer& operator=(GeneralFileBuffer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GeneralFileBuffer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GeneralFileBuffer* internal_default_instance() {
    return reinterpret_cast<const GeneralFileBuffer*>(
               &_GeneralFileBuffer_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    15;

  void Swap(GeneralFileBuffer* other);
  friend void swap(GeneralFileBuffer& a, GeneralFileBuffer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GeneralFileBuffer* New() const PROTOBUF_FINAL { return New(NULL); }

  GeneralFileBuffer* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GeneralFileBuffer& from);
  void MergeFrom(const GeneralFileBuffer& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GeneralFileBuffer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes raw_data = 1;
  void clear_raw_data();
  static const int kRawDataFieldNumber = 1;
  const ::std::string& raw_data() const;
  void set_raw_data(const ::std::string& value);
  #if LANG_CXX11
  void set_raw_data(::std::string&& value);
  #endif
  void set_raw_data(const char* value);
  void set_raw_data(const void* value, size_t size);
  ::std::string* mutable_raw_data();
  ::std::string* release_raw_data();
  void set_allocated_raw_data(::std::string* raw_data);

  // string file_name = 2;
  void clear_file_name();
  static const int kFileNameFieldNumber = 2;
  const ::std::string& file_name() const;
  void set_file_name(const ::std::string& value);
  #if LANG_CXX11
  void set_file_name(::std::string&& value);
  #endif
  void set_file_name(const char* value);
  void set_file_name(const char* value, size_t size);
  ::std::string* mutable_file_name();
  ::std::string* release_file_name();
  void set_allocated_file_name(::std::string* file_name);

  // @@protoc_insertion_point(class_scope:hiai.GeneralFileBuffer)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr raw_data_;
  ::google::protobuf::internal::ArenaStringPtr file_name_;
  mutable int _cached_size_;
  friend struct ::protobuf_ai_5ftypes_2eproto::TableStruct;
  friend void ::protobuf_ai_5ftypes_2eproto::InitDefaultsGeneralFileBufferImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// AITensorParaDescription

// string name = 1;
inline void AITensorParaDescription::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AITensorParaDescription::name() const {
  // @@protoc_insertion_point(field_get:hiai.AITensorParaDescription.name)
  return name_.GetNoArena();
}
inline void AITensorParaDescription::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hiai.AITensorParaDescription.name)
}
#if LANG_CXX11
inline void AITensorParaDescription::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hiai.AITensorParaDescription.name)
}
#endif
inline void AITensorParaDescription::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hiai.AITensorParaDescription.name)
}
inline void AITensorParaDescription::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hiai.AITensorParaDescription.name)
}
inline ::std::string* AITensorParaDescription::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:hiai.AITensorParaDescription.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AITensorParaDescription::release_name() {
  // @@protoc_insertion_point(field_release:hiai.AITensorParaDescription.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AITensorParaDescription::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:hiai.AITensorParaDescription.name)
}

// string type = 2;
inline void AITensorParaDescription::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AITensorParaDescription::type() const {
  // @@protoc_insertion_point(field_get:hiai.AITensorParaDescription.type)
  return type_.GetNoArena();
}
inline void AITensorParaDescription::set_type(const ::std::string& value) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hiai.AITensorParaDescription.type)
}
#if LANG_CXX11
inline void AITensorParaDescription::set_type(::std::string&& value) {
  
  type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hiai.AITensorParaDescription.type)
}
#endif
inline void AITensorParaDescription::set_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hiai.AITensorParaDescription.type)
}
inline void AITensorParaDescription::set_type(const char* value, size_t size) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hiai.AITensorParaDescription.type)
}
inline ::std::string* AITensorParaDescription::mutable_type() {
  
  // @@protoc_insertion_point(field_mutable:hiai.AITensorParaDescription.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AITensorParaDescription::release_type() {
  // @@protoc_insertion_point(field_release:hiai.AITensorParaDescription.type)
  
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AITensorParaDescription::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    
  } else {
    
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:hiai.AITensorParaDescription.type)
}

// string value = 3;
inline void AITensorParaDescription::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AITensorParaDescription::value() const {
  // @@protoc_insertion_point(field_get:hiai.AITensorParaDescription.value)
  return value_.GetNoArena();
}
inline void AITensorParaDescription::set_value(const ::std::string& value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hiai.AITensorParaDescription.value)
}
#if LANG_CXX11
inline void AITensorParaDescription::set_value(::std::string&& value) {
  
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hiai.AITensorParaDescription.value)
}
#endif
inline void AITensorParaDescription::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hiai.AITensorParaDescription.value)
}
inline void AITensorParaDescription::set_value(const char* value, size_t size) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hiai.AITensorParaDescription.value)
}
inline ::std::string* AITensorParaDescription::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:hiai.AITensorParaDescription.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AITensorParaDescription::release_value() {
  // @@protoc_insertion_point(field_release:hiai.AITensorParaDescription.value)
  
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AITensorParaDescription::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:hiai.AITensorParaDescription.value)
}

// string desc = 4;
inline void AITensorParaDescription::clear_desc() {
  desc_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AITensorParaDescription::desc() const {
  // @@protoc_insertion_point(field_get:hiai.AITensorParaDescription.desc)
  return desc_.GetNoArena();
}
inline void AITensorParaDescription::set_desc(const ::std::string& value) {
  
  desc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hiai.AITensorParaDescription.desc)
}
#if LANG_CXX11
inline void AITensorParaDescription::set_desc(::std::string&& value) {
  
  desc_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hiai.AITensorParaDescription.desc)
}
#endif
inline void AITensorParaDescription::set_desc(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  desc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hiai.AITensorParaDescription.desc)
}
inline void AITensorParaDescription::set_desc(const char* value, size_t size) {
  
  desc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hiai.AITensorParaDescription.desc)
}
inline ::std::string* AITensorParaDescription::mutable_desc() {
  
  // @@protoc_insertion_point(field_mutable:hiai.AITensorParaDescription.desc)
  return desc_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AITensorParaDescription::release_desc() {
  // @@protoc_insertion_point(field_release:hiai.AITensorParaDescription.desc)
  
  return desc_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AITensorParaDescription::set_allocated_desc(::std::string* desc) {
  if (desc != NULL) {
    
  } else {
    
  }
  desc_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), desc);
  // @@protoc_insertion_point(field_set_allocated:hiai.AITensorParaDescription.desc)
}

// repeated .hiai.AITensorParaDescription sub_paras = 5;
inline int AITensorParaDescription::sub_paras_size() const {
  return sub_paras_.size();
}
inline void AITensorParaDescription::clear_sub_paras() {
  sub_paras_.Clear();
}
inline const ::hiai::AITensorParaDescription& AITensorParaDescription::sub_paras(int index) const {
  // @@protoc_insertion_point(field_get:hiai.AITensorParaDescription.sub_paras)
  return sub_paras_.Get(index);
}
inline ::hiai::AITensorParaDescription* AITensorParaDescription::mutable_sub_paras(int index) {
  // @@protoc_insertion_point(field_mutable:hiai.AITensorParaDescription.sub_paras)
  return sub_paras_.Mutable(index);
}
inline ::hiai::AITensorParaDescription* AITensorParaDescription::add_sub_paras() {
  // @@protoc_insertion_point(field_add:hiai.AITensorParaDescription.sub_paras)
  return sub_paras_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::hiai::AITensorParaDescription >*
AITensorParaDescription::mutable_sub_paras() {
  // @@protoc_insertion_point(field_mutable_list:hiai.AITensorParaDescription.sub_paras)
  return &sub_paras_;
}
inline const ::google::protobuf::RepeatedPtrField< ::hiai::AITensorParaDescription >&
AITensorParaDescription::sub_paras() const {
  // @@protoc_insertion_point(field_list:hiai.AITensorParaDescription.sub_paras)
  return sub_paras_;
}

// -------------------------------------------------------------------

// AITensorDescription

// string name = 1;
inline void AITensorDescription::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AITensorDescription::name() const {
  // @@protoc_insertion_point(field_get:hiai.AITensorDescription.name)
  return name_.GetNoArena();
}
inline void AITensorDescription::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hiai.AITensorDescription.name)
}
#if LANG_CXX11
inline void AITensorDescription::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hiai.AITensorDescription.name)
}
#endif
inline void AITensorDescription::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hiai.AITensorDescription.name)
}
inline void AITensorDescription::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hiai.AITensorDescription.name)
}
inline ::std::string* AITensorDescription::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:hiai.AITensorDescription.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AITensorDescription::release_name() {
  // @@protoc_insertion_point(field_release:hiai.AITensorDescription.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AITensorDescription::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:hiai.AITensorDescription.name)
}

// string type = 2;
inline void AITensorDescription::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AITensorDescription::type() const {
  // @@protoc_insertion_point(field_get:hiai.AITensorDescription.type)
  return type_.GetNoArena();
}
inline void AITensorDescription::set_type(const ::std::string& value) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hiai.AITensorDescription.type)
}
#if LANG_CXX11
inline void AITensorDescription::set_type(::std::string&& value) {
  
  type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hiai.AITensorDescription.type)
}
#endif
inline void AITensorDescription::set_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hiai.AITensorDescription.type)
}
inline void AITensorDescription::set_type(const char* value, size_t size) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hiai.AITensorDescription.type)
}
inline ::std::string* AITensorDescription::mutable_type() {
  
  // @@protoc_insertion_point(field_mutable:hiai.AITensorDescription.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AITensorDescription::release_type() {
  // @@protoc_insertion_point(field_release:hiai.AITensorDescription.type)
  
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AITensorDescription::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    
  } else {
    
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:hiai.AITensorDescription.type)
}

// repeated string compatible_type = 3;
inline int AITensorDescription::compatible_type_size() const {
  return compatible_type_.size();
}
inline void AITensorDescription::clear_compatible_type() {
  compatible_type_.Clear();
}
inline const ::std::string& AITensorDescription::compatible_type(int index) const {
  // @@protoc_insertion_point(field_get:hiai.AITensorDescription.compatible_type)
  return compatible_type_.Get(index);
}
inline ::std::string* AITensorDescription::mutable_compatible_type(int index) {
  // @@protoc_insertion_point(field_mutable:hiai.AITensorDescription.compatible_type)
  return compatible_type_.Mutable(index);
}
inline void AITensorDescription::set_compatible_type(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:hiai.AITensorDescription.compatible_type)
  compatible_type_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void AITensorDescription::set_compatible_type(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:hiai.AITensorDescription.compatible_type)
  compatible_type_.Mutable(index)->assign(std::move(value));
}
#endif
inline void AITensorDescription::set_compatible_type(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  compatible_type_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:hiai.AITensorDescription.compatible_type)
}
inline void AITensorDescription::set_compatible_type(int index, const char* value, size_t size) {
  compatible_type_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hiai.AITensorDescription.compatible_type)
}
inline ::std::string* AITensorDescription::add_compatible_type() {
  // @@protoc_insertion_point(field_add_mutable:hiai.AITensorDescription.compatible_type)
  return compatible_type_.Add();
}
inline void AITensorDescription::add_compatible_type(const ::std::string& value) {
  compatible_type_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:hiai.AITensorDescription.compatible_type)
}
#if LANG_CXX11
inline void AITensorDescription::add_compatible_type(::std::string&& value) {
  compatible_type_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:hiai.AITensorDescription.compatible_type)
}
#endif
inline void AITensorDescription::add_compatible_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  compatible_type_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:hiai.AITensorDescription.compatible_type)
}
inline void AITensorDescription::add_compatible_type(const char* value, size_t size) {
  compatible_type_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:hiai.AITensorDescription.compatible_type)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
AITensorDescription::compatible_type() const {
  // @@protoc_insertion_point(field_list:hiai.AITensorDescription.compatible_type)
  return compatible_type_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
AITensorDescription::mutable_compatible_type() {
  // @@protoc_insertion_point(field_mutable_list:hiai.AITensorDescription.compatible_type)
  return &compatible_type_;
}

// repeated .hiai.AITensorParaDescription paras = 4;
inline int AITensorDescription::paras_size() const {
  return paras_.size();
}
inline void AITensorDescription::clear_paras() {
  paras_.Clear();
}
inline const ::hiai::AITensorParaDescription& AITensorDescription::paras(int index) const {
  // @@protoc_insertion_point(field_get:hiai.AITensorDescription.paras)
  return paras_.Get(index);
}
inline ::hiai::AITensorParaDescription* AITensorDescription::mutable_paras(int index) {
  // @@protoc_insertion_point(field_mutable:hiai.AITensorDescription.paras)
  return paras_.Mutable(index);
}
inline ::hiai::AITensorParaDescription* AITensorDescription::add_paras() {
  // @@protoc_insertion_point(field_add:hiai.AITensorDescription.paras)
  return paras_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::hiai::AITensorParaDescription >*
AITensorDescription::mutable_paras() {
  // @@protoc_insertion_point(field_mutable_list:hiai.AITensorDescription.paras)
  return &paras_;
}
inline const ::google::protobuf::RepeatedPtrField< ::hiai::AITensorParaDescription >&
AITensorDescription::paras() const {
  // @@protoc_insertion_point(field_list:hiai.AITensorDescription.paras)
  return paras_;
}

// -------------------------------------------------------------------

// AITensorDescriptionList

// repeated .hiai.AITensorDescription tensor_descs = 1;
inline int AITensorDescriptionList::tensor_descs_size() const {
  return tensor_descs_.size();
}
inline void AITensorDescriptionList::clear_tensor_descs() {
  tensor_descs_.Clear();
}
inline const ::hiai::AITensorDescription& AITensorDescriptionList::tensor_descs(int index) const {
  // @@protoc_insertion_point(field_get:hiai.AITensorDescriptionList.tensor_descs)
  return tensor_descs_.Get(index);
}
inline ::hiai::AITensorDescription* AITensorDescriptionList::mutable_tensor_descs(int index) {
  // @@protoc_insertion_point(field_mutable:hiai.AITensorDescriptionList.tensor_descs)
  return tensor_descs_.Mutable(index);
}
inline ::hiai::AITensorDescription* AITensorDescriptionList::add_tensor_descs() {
  // @@protoc_insertion_point(field_add:hiai.AITensorDescriptionList.tensor_descs)
  return tensor_descs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::hiai::AITensorDescription >*
AITensorDescriptionList::mutable_tensor_descs() {
  // @@protoc_insertion_point(field_mutable_list:hiai.AITensorDescriptionList.tensor_descs)
  return &tensor_descs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::hiai::AITensorDescription >&
AITensorDescriptionList::tensor_descs() const {
  // @@protoc_insertion_point(field_list:hiai.AITensorDescriptionList.tensor_descs)
  return tensor_descs_;
}

// -------------------------------------------------------------------

// AIConfigItem

// string name = 1;
inline void AIConfigItem::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AIConfigItem::name() const {
  // @@protoc_insertion_point(field_get:hiai.AIConfigItem.name)
  return name_.GetNoArena();
}
inline void AIConfigItem::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hiai.AIConfigItem.name)
}
#if LANG_CXX11
inline void AIConfigItem::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hiai.AIConfigItem.name)
}
#endif
inline void AIConfigItem::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hiai.AIConfigItem.name)
}
inline void AIConfigItem::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hiai.AIConfigItem.name)
}
inline ::std::string* AIConfigItem::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:hiai.AIConfigItem.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AIConfigItem::release_name() {
  // @@protoc_insertion_point(field_release:hiai.AIConfigItem.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AIConfigItem::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:hiai.AIConfigItem.name)
}

// string value = 2;
inline void AIConfigItem::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AIConfigItem::value() const {
  // @@protoc_insertion_point(field_get:hiai.AIConfigItem.value)
  return value_.GetNoArena();
}
inline void AIConfigItem::set_value(const ::std::string& value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hiai.AIConfigItem.value)
}
#if LANG_CXX11
inline void AIConfigItem::set_value(::std::string&& value) {
  
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hiai.AIConfigItem.value)
}
#endif
inline void AIConfigItem::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hiai.AIConfigItem.value)
}
inline void AIConfigItem::set_value(const char* value, size_t size) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hiai.AIConfigItem.value)
}
inline ::std::string* AIConfigItem::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:hiai.AIConfigItem.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AIConfigItem::release_value() {
  // @@protoc_insertion_point(field_release:hiai.AIConfigItem.value)
  
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AIConfigItem::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:hiai.AIConfigItem.value)
}

// repeated .hiai.AIConfigItem sub_items = 3;
inline int AIConfigItem::sub_items_size() const {
  return sub_items_.size();
}
inline void AIConfigItem::clear_sub_items() {
  sub_items_.Clear();
}
inline const ::hiai::AIConfigItem& AIConfigItem::sub_items(int index) const {
  // @@protoc_insertion_point(field_get:hiai.AIConfigItem.sub_items)
  return sub_items_.Get(index);
}
inline ::hiai::AIConfigItem* AIConfigItem::mutable_sub_items(int index) {
  // @@protoc_insertion_point(field_mutable:hiai.AIConfigItem.sub_items)
  return sub_items_.Mutable(index);
}
inline ::hiai::AIConfigItem* AIConfigItem::add_sub_items() {
  // @@protoc_insertion_point(field_add:hiai.AIConfigItem.sub_items)
  return sub_items_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::hiai::AIConfigItem >*
AIConfigItem::mutable_sub_items() {
  // @@protoc_insertion_point(field_mutable_list:hiai.AIConfigItem.sub_items)
  return &sub_items_;
}
inline const ::google::protobuf::RepeatedPtrField< ::hiai::AIConfigItem >&
AIConfigItem::sub_items() const {
  // @@protoc_insertion_point(field_list:hiai.AIConfigItem.sub_items)
  return sub_items_;
}

// -------------------------------------------------------------------

// AIConfig

// repeated .hiai.AIConfigItem items = 1;
inline int AIConfig::items_size() const {
  return items_.size();
}
inline void AIConfig::clear_items() {
  items_.Clear();
}
inline const ::hiai::AIConfigItem& AIConfig::items(int index) const {
  // @@protoc_insertion_point(field_get:hiai.AIConfig.items)
  return items_.Get(index);
}
inline ::hiai::AIConfigItem* AIConfig::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:hiai.AIConfig.items)
  return items_.Mutable(index);
}
inline ::hiai::AIConfigItem* AIConfig::add_items() {
  // @@protoc_insertion_point(field_add:hiai.AIConfig.items)
  return items_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::hiai::AIConfigItem >*
AIConfig::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:hiai.AIConfig.items)
  return &items_;
}
inline const ::google::protobuf::RepeatedPtrField< ::hiai::AIConfigItem >&
AIConfig::items() const {
  // @@protoc_insertion_point(field_list:hiai.AIConfig.items)
  return items_;
}

// -------------------------------------------------------------------

// AIModelDescription

// string name = 1;
inline void AIModelDescription::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AIModelDescription::name() const {
  // @@protoc_insertion_point(field_get:hiai.AIModelDescription.name)
  return name_.GetNoArena();
}
inline void AIModelDescription::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hiai.AIModelDescription.name)
}
#if LANG_CXX11
inline void AIModelDescription::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hiai.AIModelDescription.name)
}
#endif
inline void AIModelDescription::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hiai.AIModelDescription.name)
}
inline void AIModelDescription::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hiai.AIModelDescription.name)
}
inline ::std::string* AIModelDescription::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:hiai.AIModelDescription.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AIModelDescription::release_name() {
  // @@protoc_insertion_point(field_release:hiai.AIModelDescription.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AIModelDescription::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:hiai.AIModelDescription.name)
}

// int32 type = 2;
inline void AIModelDescription::clear_type() {
  type_ = 0;
}
inline ::google::protobuf::int32 AIModelDescription::type() const {
  // @@protoc_insertion_point(field_get:hiai.AIModelDescription.type)
  return type_;
}
inline void AIModelDescription::set_type(::google::protobuf::int32 value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:hiai.AIModelDescription.type)
}

// string version = 3;
inline void AIModelDescription::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AIModelDescription::version() const {
  // @@protoc_insertion_point(field_get:hiai.AIModelDescription.version)
  return version_.GetNoArena();
}
inline void AIModelDescription::set_version(const ::std::string& value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hiai.AIModelDescription.version)
}
#if LANG_CXX11
inline void AIModelDescription::set_version(::std::string&& value) {
  
  version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hiai.AIModelDescription.version)
}
#endif
inline void AIModelDescription::set_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hiai.AIModelDescription.version)
}
inline void AIModelDescription::set_version(const char* value, size_t size) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hiai.AIModelDescription.version)
}
inline ::std::string* AIModelDescription::mutable_version() {
  
  // @@protoc_insertion_point(field_mutable:hiai.AIModelDescription.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AIModelDescription::release_version() {
  // @@protoc_insertion_point(field_release:hiai.AIModelDescription.version)
  
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AIModelDescription::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    
  } else {
    
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:hiai.AIModelDescription.version)
}

// int32 size = 4;
inline void AIModelDescription::clear_size() {
  size_ = 0;
}
inline ::google::protobuf::int32 AIModelDescription::size() const {
  // @@protoc_insertion_point(field_get:hiai.AIModelDescription.size)
  return size_;
}
inline void AIModelDescription::set_size(::google::protobuf::int32 value) {
  
  size_ = value;
  // @@protoc_insertion_point(field_set:hiai.AIModelDescription.size)
}

// string path = 5;
inline void AIModelDescription::clear_path() {
  path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AIModelDescription::path() const {
  // @@protoc_insertion_point(field_get:hiai.AIModelDescription.path)
  return path_.GetNoArena();
}
inline void AIModelDescription::set_path(const ::std::string& value) {
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hiai.AIModelDescription.path)
}
#if LANG_CXX11
inline void AIModelDescription::set_path(::std::string&& value) {
  
  path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hiai.AIModelDescription.path)
}
#endif
inline void AIModelDescription::set_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hiai.AIModelDescription.path)
}
inline void AIModelDescription::set_path(const char* value, size_t size) {
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hiai.AIModelDescription.path)
}
inline ::std::string* AIModelDescription::mutable_path() {
  
  // @@protoc_insertion_point(field_mutable:hiai.AIModelDescription.path)
  return path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AIModelDescription::release_path() {
  // @@protoc_insertion_point(field_release:hiai.AIModelDescription.path)
  
  return path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AIModelDescription::set_allocated_path(::std::string* path) {
  if (path != NULL) {
    
  } else {
    
  }
  path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), path);
  // @@protoc_insertion_point(field_set_allocated:hiai.AIModelDescription.path)
}

// repeated string sub_path = 6;
inline int AIModelDescription::sub_path_size() const {
  return sub_path_.size();
}
inline void AIModelDescription::clear_sub_path() {
  sub_path_.Clear();
}
inline const ::std::string& AIModelDescription::sub_path(int index) const {
  // @@protoc_insertion_point(field_get:hiai.AIModelDescription.sub_path)
  return sub_path_.Get(index);
}
inline ::std::string* AIModelDescription::mutable_sub_path(int index) {
  // @@protoc_insertion_point(field_mutable:hiai.AIModelDescription.sub_path)
  return sub_path_.Mutable(index);
}
inline void AIModelDescription::set_sub_path(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:hiai.AIModelDescription.sub_path)
  sub_path_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void AIModelDescription::set_sub_path(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:hiai.AIModelDescription.sub_path)
  sub_path_.Mutable(index)->assign(std::move(value));
}
#endif
inline void AIModelDescription::set_sub_path(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  sub_path_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:hiai.AIModelDescription.sub_path)
}
inline void AIModelDescription::set_sub_path(int index, const char* value, size_t size) {
  sub_path_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hiai.AIModelDescription.sub_path)
}
inline ::std::string* AIModelDescription::add_sub_path() {
  // @@protoc_insertion_point(field_add_mutable:hiai.AIModelDescription.sub_path)
  return sub_path_.Add();
}
inline void AIModelDescription::add_sub_path(const ::std::string& value) {
  sub_path_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:hiai.AIModelDescription.sub_path)
}
#if LANG_CXX11
inline void AIModelDescription::add_sub_path(::std::string&& value) {
  sub_path_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:hiai.AIModelDescription.sub_path)
}
#endif
inline void AIModelDescription::add_sub_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  sub_path_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:hiai.AIModelDescription.sub_path)
}
inline void AIModelDescription::add_sub_path(const char* value, size_t size) {
  sub_path_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:hiai.AIModelDescription.sub_path)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
AIModelDescription::sub_path() const {
  // @@protoc_insertion_point(field_list:hiai.AIModelDescription.sub_path)
  return sub_path_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
AIModelDescription::mutable_sub_path() {
  // @@protoc_insertion_point(field_mutable_list:hiai.AIModelDescription.sub_path)
  return &sub_path_;
}

// string key = 7;
inline void AIModelDescription::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AIModelDescription::key() const {
  // @@protoc_insertion_point(field_get:hiai.AIModelDescription.key)
  return key_.GetNoArena();
}
inline void AIModelDescription::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hiai.AIModelDescription.key)
}
#if LANG_CXX11
inline void AIModelDescription::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hiai.AIModelDescription.key)
}
#endif
inline void AIModelDescription::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hiai.AIModelDescription.key)
}
inline void AIModelDescription::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hiai.AIModelDescription.key)
}
inline ::std::string* AIModelDescription::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:hiai.AIModelDescription.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AIModelDescription::release_key() {
  // @@protoc_insertion_point(field_release:hiai.AIModelDescription.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AIModelDescription::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:hiai.AIModelDescription.key)
}

// repeated string sub_key = 8;
inline int AIModelDescription::sub_key_size() const {
  return sub_key_.size();
}
inline void AIModelDescription::clear_sub_key() {
  sub_key_.Clear();
}
inline const ::std::string& AIModelDescription::sub_key(int index) const {
  // @@protoc_insertion_point(field_get:hiai.AIModelDescription.sub_key)
  return sub_key_.Get(index);
}
inline ::std::string* AIModelDescription::mutable_sub_key(int index) {
  // @@protoc_insertion_point(field_mutable:hiai.AIModelDescription.sub_key)
  return sub_key_.Mutable(index);
}
inline void AIModelDescription::set_sub_key(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:hiai.AIModelDescription.sub_key)
  sub_key_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void AIModelDescription::set_sub_key(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:hiai.AIModelDescription.sub_key)
  sub_key_.Mutable(index)->assign(std::move(value));
}
#endif
inline void AIModelDescription::set_sub_key(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  sub_key_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:hiai.AIModelDescription.sub_key)
}
inline void AIModelDescription::set_sub_key(int index, const char* value, size_t size) {
  sub_key_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hiai.AIModelDescription.sub_key)
}
inline ::std::string* AIModelDescription::add_sub_key() {
  // @@protoc_insertion_point(field_add_mutable:hiai.AIModelDescription.sub_key)
  return sub_key_.Add();
}
inline void AIModelDescription::add_sub_key(const ::std::string& value) {
  sub_key_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:hiai.AIModelDescription.sub_key)
}
#if LANG_CXX11
inline void AIModelDescription::add_sub_key(::std::string&& value) {
  sub_key_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:hiai.AIModelDescription.sub_key)
}
#endif
inline void AIModelDescription::add_sub_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  sub_key_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:hiai.AIModelDescription.sub_key)
}
inline void AIModelDescription::add_sub_key(const char* value, size_t size) {
  sub_key_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:hiai.AIModelDescription.sub_key)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
AIModelDescription::sub_key() const {
  // @@protoc_insertion_point(field_list:hiai.AIModelDescription.sub_key)
  return sub_key_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
AIModelDescription::mutable_sub_key() {
  // @@protoc_insertion_point(field_mutable_list:hiai.AIModelDescription.sub_key)
  return &sub_key_;
}

// .hiai.AIModelDescription.Frequency frequency = 9;
inline void AIModelDescription::clear_frequency() {
  frequency_ = 0;
}
inline ::hiai::AIModelDescription_Frequency AIModelDescription::frequency() const {
  // @@protoc_insertion_point(field_get:hiai.AIModelDescription.frequency)
  return static_cast< ::hiai::AIModelDescription_Frequency >(frequency_);
}
inline void AIModelDescription::set_frequency(::hiai::AIModelDescription_Frequency value) {
  
  frequency_ = value;
  // @@protoc_insertion_point(field_set:hiai.AIModelDescription.frequency)
}

// .hiai.AIModelDescription.DeviceType device_type = 10;
inline void AIModelDescription::clear_device_type() {
  device_type_ = 0;
}
inline ::hiai::AIModelDescription_DeviceType AIModelDescription::device_type() const {
  // @@protoc_insertion_point(field_get:hiai.AIModelDescription.device_type)
  return static_cast< ::hiai::AIModelDescription_DeviceType >(device_type_);
}
inline void AIModelDescription::set_device_type(::hiai::AIModelDescription_DeviceType value) {
  
  device_type_ = value;
  // @@protoc_insertion_point(field_set:hiai.AIModelDescription.device_type)
}

// .hiai.AIModelDescription.Framework framework = 11;
inline void AIModelDescription::clear_framework() {
  framework_ = 0;
}
inline ::hiai::AIModelDescription_Framework AIModelDescription::framework() const {
  // @@protoc_insertion_point(field_get:hiai.AIModelDescription.framework)
  return static_cast< ::hiai::AIModelDescription_Framework >(framework_);
}
inline void AIModelDescription::set_framework(::hiai::AIModelDescription_Framework value) {
  
  framework_ = value;
  // @@protoc_insertion_point(field_set:hiai.AIModelDescription.framework)
}

// bytes data = 100;
inline void AIModelDescription::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AIModelDescription::data() const {
  // @@protoc_insertion_point(field_get:hiai.AIModelDescription.data)
  return data_.GetNoArena();
}
inline void AIModelDescription::set_data(const ::std::string& value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hiai.AIModelDescription.data)
}
#if LANG_CXX11
inline void AIModelDescription::set_data(::std::string&& value) {
  
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hiai.AIModelDescription.data)
}
#endif
inline void AIModelDescription::set_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hiai.AIModelDescription.data)
}
inline void AIModelDescription::set_data(const void* value, size_t size) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hiai.AIModelDescription.data)
}
inline ::std::string* AIModelDescription::mutable_data() {
  
  // @@protoc_insertion_point(field_mutable:hiai.AIModelDescription.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AIModelDescription::release_data() {
  // @@protoc_insertion_point(field_release:hiai.AIModelDescription.data)
  
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AIModelDescription::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    
  } else {
    
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:hiai.AIModelDescription.data)
}

// repeated .hiai.AITensorDescription inputs = 12;
inline int AIModelDescription::inputs_size() const {
  return inputs_.size();
}
inline void AIModelDescription::clear_inputs() {
  inputs_.Clear();
}
inline const ::hiai::AITensorDescription& AIModelDescription::inputs(int index) const {
  // @@protoc_insertion_point(field_get:hiai.AIModelDescription.inputs)
  return inputs_.Get(index);
}
inline ::hiai::AITensorDescription* AIModelDescription::mutable_inputs(int index) {
  // @@protoc_insertion_point(field_mutable:hiai.AIModelDescription.inputs)
  return inputs_.Mutable(index);
}
inline ::hiai::AITensorDescription* AIModelDescription::add_inputs() {
  // @@protoc_insertion_point(field_add:hiai.AIModelDescription.inputs)
  return inputs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::hiai::AITensorDescription >*
AIModelDescription::mutable_inputs() {
  // @@protoc_insertion_point(field_mutable_list:hiai.AIModelDescription.inputs)
  return &inputs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::hiai::AITensorDescription >&
AIModelDescription::inputs() const {
  // @@protoc_insertion_point(field_list:hiai.AIModelDescription.inputs)
  return inputs_;
}

// repeated .hiai.AITensorDescription outputs = 13;
inline int AIModelDescription::outputs_size() const {
  return outputs_.size();
}
inline void AIModelDescription::clear_outputs() {
  outputs_.Clear();
}
inline const ::hiai::AITensorDescription& AIModelDescription::outputs(int index) const {
  // @@protoc_insertion_point(field_get:hiai.AIModelDescription.outputs)
  return outputs_.Get(index);
}
inline ::hiai::AITensorDescription* AIModelDescription::mutable_outputs(int index) {
  // @@protoc_insertion_point(field_mutable:hiai.AIModelDescription.outputs)
  return outputs_.Mutable(index);
}
inline ::hiai::AITensorDescription* AIModelDescription::add_outputs() {
  // @@protoc_insertion_point(field_add:hiai.AIModelDescription.outputs)
  return outputs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::hiai::AITensorDescription >*
AIModelDescription::mutable_outputs() {
  // @@protoc_insertion_point(field_mutable_list:hiai.AIModelDescription.outputs)
  return &outputs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::hiai::AITensorDescription >&
AIModelDescription::outputs() const {
  // @@protoc_insertion_point(field_list:hiai.AIModelDescription.outputs)
  return outputs_;
}

// -------------------------------------------------------------------

// AINNNodeDescription

// string name = 1;
inline void AINNNodeDescription::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AINNNodeDescription::name() const {
  // @@protoc_insertion_point(field_get:hiai.AINNNodeDescription.name)
  return name_.GetNoArena();
}
inline void AINNNodeDescription::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hiai.AINNNodeDescription.name)
}
#if LANG_CXX11
inline void AINNNodeDescription::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hiai.AINNNodeDescription.name)
}
#endif
inline void AINNNodeDescription::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hiai.AINNNodeDescription.name)
}
inline void AINNNodeDescription::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hiai.AINNNodeDescription.name)
}
inline ::std::string* AINNNodeDescription::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:hiai.AINNNodeDescription.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AINNNodeDescription::release_name() {
  // @@protoc_insertion_point(field_release:hiai.AINNNodeDescription.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AINNNodeDescription::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:hiai.AINNNodeDescription.name)
}

// string desc = 2;
inline void AINNNodeDescription::clear_desc() {
  desc_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AINNNodeDescription::desc() const {
  // @@protoc_insertion_point(field_get:hiai.AINNNodeDescription.desc)
  return desc_.GetNoArena();
}
inline void AINNNodeDescription::set_desc(const ::std::string& value) {
  
  desc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hiai.AINNNodeDescription.desc)
}
#if LANG_CXX11
inline void AINNNodeDescription::set_desc(::std::string&& value) {
  
  desc_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hiai.AINNNodeDescription.desc)
}
#endif
inline void AINNNodeDescription::set_desc(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  desc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hiai.AINNNodeDescription.desc)
}
inline void AINNNodeDescription::set_desc(const char* value, size_t size) {
  
  desc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hiai.AINNNodeDescription.desc)
}
inline ::std::string* AINNNodeDescription::mutable_desc() {
  
  // @@protoc_insertion_point(field_mutable:hiai.AINNNodeDescription.desc)
  return desc_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AINNNodeDescription::release_desc() {
  // @@protoc_insertion_point(field_release:hiai.AINNNodeDescription.desc)
  
  return desc_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AINNNodeDescription::set_allocated_desc(::std::string* desc) {
  if (desc != NULL) {
    
  } else {
    
  }
  desc_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), desc);
  // @@protoc_insertion_point(field_set_allocated:hiai.AINNNodeDescription.desc)
}

// bool isPreAllocateOutputMem = 3;
inline void AINNNodeDescription::clear_ispreallocateoutputmem() {
  ispreallocateoutputmem_ = false;
}
inline bool AINNNodeDescription::ispreallocateoutputmem() const {
  // @@protoc_insertion_point(field_get:hiai.AINNNodeDescription.isPreAllocateOutputMem)
  return ispreallocateoutputmem_;
}
inline void AINNNodeDescription::set_ispreallocateoutputmem(bool value) {
  
  ispreallocateoutputmem_ = value;
  // @@protoc_insertion_point(field_set:hiai.AINNNodeDescription.isPreAllocateOutputMem)
}

// .hiai.AIConfig config = 4;
inline bool AINNNodeDescription::has_config() const {
  return this != internal_default_instance() && config_ != NULL;
}
inline void AINNNodeDescription::clear_config() {
  if (GetArenaNoVirtual() == NULL && config_ != NULL) {
    delete config_;
  }
  config_ = NULL;
}
inline const ::hiai::AIConfig& AINNNodeDescription::config() const {
  const ::hiai::AIConfig* p = config_;
  // @@protoc_insertion_point(field_get:hiai.AINNNodeDescription.config)
  return p != NULL ? *p : *reinterpret_cast<const ::hiai::AIConfig*>(
      &::hiai::_AIConfig_default_instance_);
}
inline ::hiai::AIConfig* AINNNodeDescription::release_config() {
  // @@protoc_insertion_point(field_release:hiai.AINNNodeDescription.config)
  
  ::hiai::AIConfig* temp = config_;
  config_ = NULL;
  return temp;
}
inline ::hiai::AIConfig* AINNNodeDescription::mutable_config() {
  
  if (config_ == NULL) {
    config_ = new ::hiai::AIConfig;
  }
  // @@protoc_insertion_point(field_mutable:hiai.AINNNodeDescription.config)
  return config_;
}
inline void AINNNodeDescription::set_allocated_config(::hiai::AIConfig* config) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete config_;
  }
  if (config) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      config = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, config, submessage_arena);
    }
    
  } else {
    
  }
  config_ = config;
  // @@protoc_insertion_point(field_set_allocated:hiai.AINNNodeDescription.config)
}

// repeated .hiai.AIModelDescription model_list = 5;
inline int AINNNodeDescription::model_list_size() const {
  return model_list_.size();
}
inline void AINNNodeDescription::clear_model_list() {
  model_list_.Clear();
}
inline const ::hiai::AIModelDescription& AINNNodeDescription::model_list(int index) const {
  // @@protoc_insertion_point(field_get:hiai.AINNNodeDescription.model_list)
  return model_list_.Get(index);
}
inline ::hiai::AIModelDescription* AINNNodeDescription::mutable_model_list(int index) {
  // @@protoc_insertion_point(field_mutable:hiai.AINNNodeDescription.model_list)
  return model_list_.Mutable(index);
}
inline ::hiai::AIModelDescription* AINNNodeDescription::add_model_list() {
  // @@protoc_insertion_point(field_add:hiai.AINNNodeDescription.model_list)
  return model_list_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::hiai::AIModelDescription >*
AINNNodeDescription::mutable_model_list() {
  // @@protoc_insertion_point(field_mutable_list:hiai.AINNNodeDescription.model_list)
  return &model_list_;
}
inline const ::google::protobuf::RepeatedPtrField< ::hiai::AIModelDescription >&
AINNNodeDescription::model_list() const {
  // @@protoc_insertion_point(field_list:hiai.AINNNodeDescription.model_list)
  return model_list_;
}

// repeated .hiai.AITensorDescription inputs = 6;
inline int AINNNodeDescription::inputs_size() const {
  return inputs_.size();
}
inline void AINNNodeDescription::clear_inputs() {
  inputs_.Clear();
}
inline const ::hiai::AITensorDescription& AINNNodeDescription::inputs(int index) const {
  // @@protoc_insertion_point(field_get:hiai.AINNNodeDescription.inputs)
  return inputs_.Get(index);
}
inline ::hiai::AITensorDescription* AINNNodeDescription::mutable_inputs(int index) {
  // @@protoc_insertion_point(field_mutable:hiai.AINNNodeDescription.inputs)
  return inputs_.Mutable(index);
}
inline ::hiai::AITensorDescription* AINNNodeDescription::add_inputs() {
  // @@protoc_insertion_point(field_add:hiai.AINNNodeDescription.inputs)
  return inputs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::hiai::AITensorDescription >*
AINNNodeDescription::mutable_inputs() {
  // @@protoc_insertion_point(field_mutable_list:hiai.AINNNodeDescription.inputs)
  return &inputs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::hiai::AITensorDescription >&
AINNNodeDescription::inputs() const {
  // @@protoc_insertion_point(field_list:hiai.AINNNodeDescription.inputs)
  return inputs_;
}

// repeated .hiai.AITensorDescription outputs = 7;
inline int AINNNodeDescription::outputs_size() const {
  return outputs_.size();
}
inline void AINNNodeDescription::clear_outputs() {
  outputs_.Clear();
}
inline const ::hiai::AITensorDescription& AINNNodeDescription::outputs(int index) const {
  // @@protoc_insertion_point(field_get:hiai.AINNNodeDescription.outputs)
  return outputs_.Get(index);
}
inline ::hiai::AITensorDescription* AINNNodeDescription::mutable_outputs(int index) {
  // @@protoc_insertion_point(field_mutable:hiai.AINNNodeDescription.outputs)
  return outputs_.Mutable(index);
}
inline ::hiai::AITensorDescription* AINNNodeDescription::add_outputs() {
  // @@protoc_insertion_point(field_add:hiai.AINNNodeDescription.outputs)
  return outputs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::hiai::AITensorDescription >*
AINNNodeDescription::mutable_outputs() {
  // @@protoc_insertion_point(field_mutable_list:hiai.AINNNodeDescription.outputs)
  return &outputs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::hiai::AITensorDescription >&
AINNNodeDescription::outputs() const {
  // @@protoc_insertion_point(field_list:hiai.AINNNodeDescription.outputs)
  return outputs_;
}

// bool need_verify = 8;
inline void AINNNodeDescription::clear_need_verify() {
  need_verify_ = false;
}
inline bool AINNNodeDescription::need_verify() const {
  // @@protoc_insertion_point(field_get:hiai.AINNNodeDescription.need_verify)
  return need_verify_;
}
inline void AINNNodeDescription::set_need_verify(bool value) {
  
  need_verify_ = value;
  // @@protoc_insertion_point(field_set:hiai.AINNNodeDescription.need_verify)
}

// repeated string ignored_check_aitensor = 9;
inline int AINNNodeDescription::ignored_check_aitensor_size() const {
  return ignored_check_aitensor_.size();
}
inline void AINNNodeDescription::clear_ignored_check_aitensor() {
  ignored_check_aitensor_.Clear();
}
inline const ::std::string& AINNNodeDescription::ignored_check_aitensor(int index) const {
  // @@protoc_insertion_point(field_get:hiai.AINNNodeDescription.ignored_check_aitensor)
  return ignored_check_aitensor_.Get(index);
}
inline ::std::string* AINNNodeDescription::mutable_ignored_check_aitensor(int index) {
  // @@protoc_insertion_point(field_mutable:hiai.AINNNodeDescription.ignored_check_aitensor)
  return ignored_check_aitensor_.Mutable(index);
}
inline void AINNNodeDescription::set_ignored_check_aitensor(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:hiai.AINNNodeDescription.ignored_check_aitensor)
  ignored_check_aitensor_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void AINNNodeDescription::set_ignored_check_aitensor(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:hiai.AINNNodeDescription.ignored_check_aitensor)
  ignored_check_aitensor_.Mutable(index)->assign(std::move(value));
}
#endif
inline void AINNNodeDescription::set_ignored_check_aitensor(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  ignored_check_aitensor_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:hiai.AINNNodeDescription.ignored_check_aitensor)
}
inline void AINNNodeDescription::set_ignored_check_aitensor(int index, const char* value, size_t size) {
  ignored_check_aitensor_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hiai.AINNNodeDescription.ignored_check_aitensor)
}
inline ::std::string* AINNNodeDescription::add_ignored_check_aitensor() {
  // @@protoc_insertion_point(field_add_mutable:hiai.AINNNodeDescription.ignored_check_aitensor)
  return ignored_check_aitensor_.Add();
}
inline void AINNNodeDescription::add_ignored_check_aitensor(const ::std::string& value) {
  ignored_check_aitensor_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:hiai.AINNNodeDescription.ignored_check_aitensor)
}
#if LANG_CXX11
inline void AINNNodeDescription::add_ignored_check_aitensor(::std::string&& value) {
  ignored_check_aitensor_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:hiai.AINNNodeDescription.ignored_check_aitensor)
}
#endif
inline void AINNNodeDescription::add_ignored_check_aitensor(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  ignored_check_aitensor_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:hiai.AINNNodeDescription.ignored_check_aitensor)
}
inline void AINNNodeDescription::add_ignored_check_aitensor(const char* value, size_t size) {
  ignored_check_aitensor_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:hiai.AINNNodeDescription.ignored_check_aitensor)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
AINNNodeDescription::ignored_check_aitensor() const {
  // @@protoc_insertion_point(field_list:hiai.AINNNodeDescription.ignored_check_aitensor)
  return ignored_check_aitensor_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
AINNNodeDescription::mutable_ignored_check_aitensor() {
  // @@protoc_insertion_point(field_mutable_list:hiai.AINNNodeDescription.ignored_check_aitensor)
  return &ignored_check_aitensor_;
}

// -------------------------------------------------------------------

// AINNNodeDescriptionList

// repeated .hiai.AINNNodeDescription nnnode_descs = 1;
inline int AINNNodeDescriptionList::nnnode_descs_size() const {
  return nnnode_descs_.size();
}
inline void AINNNodeDescriptionList::clear_nnnode_descs() {
  nnnode_descs_.Clear();
}
inline const ::hiai::AINNNodeDescription& AINNNodeDescriptionList::nnnode_descs(int index) const {
  // @@protoc_insertion_point(field_get:hiai.AINNNodeDescriptionList.nnnode_descs)
  return nnnode_descs_.Get(index);
}
inline ::hiai::AINNNodeDescription* AINNNodeDescriptionList::mutable_nnnode_descs(int index) {
  // @@protoc_insertion_point(field_mutable:hiai.AINNNodeDescriptionList.nnnode_descs)
  return nnnode_descs_.Mutable(index);
}
inline ::hiai::AINNNodeDescription* AINNNodeDescriptionList::add_nnnode_descs() {
  // @@protoc_insertion_point(field_add:hiai.AINNNodeDescriptionList.nnnode_descs)
  return nnnode_descs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::hiai::AINNNodeDescription >*
AINNNodeDescriptionList::mutable_nnnode_descs() {
  // @@protoc_insertion_point(field_mutable_list:hiai.AINNNodeDescriptionList.nnnode_descs)
  return &nnnode_descs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::hiai::AINNNodeDescription >&
AINNNodeDescriptionList::nnnode_descs() const {
  // @@protoc_insertion_point(field_list:hiai.AINNNodeDescriptionList.nnnode_descs)
  return nnnode_descs_;
}

// -------------------------------------------------------------------

// AIAPIDescription

// string name = 1;
inline void AIAPIDescription::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AIAPIDescription::name() const {
  // @@protoc_insertion_point(field_get:hiai.AIAPIDescription.name)
  return name_.GetNoArena();
}
inline void AIAPIDescription::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hiai.AIAPIDescription.name)
}
#if LANG_CXX11
inline void AIAPIDescription::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hiai.AIAPIDescription.name)
}
#endif
inline void AIAPIDescription::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hiai.AIAPIDescription.name)
}
inline void AIAPIDescription::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hiai.AIAPIDescription.name)
}
inline ::std::string* AIAPIDescription::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:hiai.AIAPIDescription.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AIAPIDescription::release_name() {
  // @@protoc_insertion_point(field_release:hiai.AIAPIDescription.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AIAPIDescription::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:hiai.AIAPIDescription.name)
}

// string desc = 2;
inline void AIAPIDescription::clear_desc() {
  desc_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AIAPIDescription::desc() const {
  // @@protoc_insertion_point(field_get:hiai.AIAPIDescription.desc)
  return desc_.GetNoArena();
}
inline void AIAPIDescription::set_desc(const ::std::string& value) {
  
  desc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hiai.AIAPIDescription.desc)
}
#if LANG_CXX11
inline void AIAPIDescription::set_desc(::std::string&& value) {
  
  desc_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hiai.AIAPIDescription.desc)
}
#endif
inline void AIAPIDescription::set_desc(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  desc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hiai.AIAPIDescription.desc)
}
inline void AIAPIDescription::set_desc(const char* value, size_t size) {
  
  desc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hiai.AIAPIDescription.desc)
}
inline ::std::string* AIAPIDescription::mutable_desc() {
  
  // @@protoc_insertion_point(field_mutable:hiai.AIAPIDescription.desc)
  return desc_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AIAPIDescription::release_desc() {
  // @@protoc_insertion_point(field_release:hiai.AIAPIDescription.desc)
  
  return desc_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AIAPIDescription::set_allocated_desc(::std::string* desc) {
  if (desc != NULL) {
    
  } else {
    
  }
  desc_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), desc);
  // @@protoc_insertion_point(field_set_allocated:hiai.AIAPIDescription.desc)
}

// bool isPreAllocateOutputMem = 3;
inline void AIAPIDescription::clear_ispreallocateoutputmem() {
  ispreallocateoutputmem_ = false;
}
inline bool AIAPIDescription::ispreallocateoutputmem() const {
  // @@protoc_insertion_point(field_get:hiai.AIAPIDescription.isPreAllocateOutputMem)
  return ispreallocateoutputmem_;
}
inline void AIAPIDescription::set_ispreallocateoutputmem(bool value) {
  
  ispreallocateoutputmem_ = value;
  // @@protoc_insertion_point(field_set:hiai.AIAPIDescription.isPreAllocateOutputMem)
}

// .hiai.AIConfig config = 4;
inline bool AIAPIDescription::has_config() const {
  return this != internal_default_instance() && config_ != NULL;
}
inline void AIAPIDescription::clear_config() {
  if (GetArenaNoVirtual() == NULL && config_ != NULL) {
    delete config_;
  }
  config_ = NULL;
}
inline const ::hiai::AIConfig& AIAPIDescription::config() const {
  const ::hiai::AIConfig* p = config_;
  // @@protoc_insertion_point(field_get:hiai.AIAPIDescription.config)
  return p != NULL ? *p : *reinterpret_cast<const ::hiai::AIConfig*>(
      &::hiai::_AIConfig_default_instance_);
}
inline ::hiai::AIConfig* AIAPIDescription::release_config() {
  // @@protoc_insertion_point(field_release:hiai.AIAPIDescription.config)
  
  ::hiai::AIConfig* temp = config_;
  config_ = NULL;
  return temp;
}
inline ::hiai::AIConfig* AIAPIDescription::mutable_config() {
  
  if (config_ == NULL) {
    config_ = new ::hiai::AIConfig;
  }
  // @@protoc_insertion_point(field_mutable:hiai.AIAPIDescription.config)
  return config_;
}
inline void AIAPIDescription::set_allocated_config(::hiai::AIConfig* config) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete config_;
  }
  if (config) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      config = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, config, submessage_arena);
    }
    
  } else {
    
  }
  config_ = config;
  // @@protoc_insertion_point(field_set_allocated:hiai.AIAPIDescription.config)
}

// repeated .hiai.AITensorDescription inputs = 5;
inline int AIAPIDescription::inputs_size() const {
  return inputs_.size();
}
inline void AIAPIDescription::clear_inputs() {
  inputs_.Clear();
}
inline const ::hiai::AITensorDescription& AIAPIDescription::inputs(int index) const {
  // @@protoc_insertion_point(field_get:hiai.AIAPIDescription.inputs)
  return inputs_.Get(index);
}
inline ::hiai::AITensorDescription* AIAPIDescription::mutable_inputs(int index) {
  // @@protoc_insertion_point(field_mutable:hiai.AIAPIDescription.inputs)
  return inputs_.Mutable(index);
}
inline ::hiai::AITensorDescription* AIAPIDescription::add_inputs() {
  // @@protoc_insertion_point(field_add:hiai.AIAPIDescription.inputs)
  return inputs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::hiai::AITensorDescription >*
AIAPIDescription::mutable_inputs() {
  // @@protoc_insertion_point(field_mutable_list:hiai.AIAPIDescription.inputs)
  return &inputs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::hiai::AITensorDescription >&
AIAPIDescription::inputs() const {
  // @@protoc_insertion_point(field_list:hiai.AIAPIDescription.inputs)
  return inputs_;
}

// repeated .hiai.AITensorDescription outputs = 6;
inline int AIAPIDescription::outputs_size() const {
  return outputs_.size();
}
inline void AIAPIDescription::clear_outputs() {
  outputs_.Clear();
}
inline const ::hiai::AITensorDescription& AIAPIDescription::outputs(int index) const {
  // @@protoc_insertion_point(field_get:hiai.AIAPIDescription.outputs)
  return outputs_.Get(index);
}
inline ::hiai::AITensorDescription* AIAPIDescription::mutable_outputs(int index) {
  // @@protoc_insertion_point(field_mutable:hiai.AIAPIDescription.outputs)
  return outputs_.Mutable(index);
}
inline ::hiai::AITensorDescription* AIAPIDescription::add_outputs() {
  // @@protoc_insertion_point(field_add:hiai.AIAPIDescription.outputs)
  return outputs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::hiai::AITensorDescription >*
AIAPIDescription::mutable_outputs() {
  // @@protoc_insertion_point(field_mutable_list:hiai.AIAPIDescription.outputs)
  return &outputs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::hiai::AITensorDescription >&
AIAPIDescription::outputs() const {
  // @@protoc_insertion_point(field_list:hiai.AIAPIDescription.outputs)
  return outputs_;
}

// bool need_verify = 7;
inline void AIAPIDescription::clear_need_verify() {
  need_verify_ = false;
}
inline bool AIAPIDescription::need_verify() const {
  // @@protoc_insertion_point(field_get:hiai.AIAPIDescription.need_verify)
  return need_verify_;
}
inline void AIAPIDescription::set_need_verify(bool value) {
  
  need_verify_ = value;
  // @@protoc_insertion_point(field_set:hiai.AIAPIDescription.need_verify)
}

// repeated string ignored_check_aitensor = 8;
inline int AIAPIDescription::ignored_check_aitensor_size() const {
  return ignored_check_aitensor_.size();
}
inline void AIAPIDescription::clear_ignored_check_aitensor() {
  ignored_check_aitensor_.Clear();
}
inline const ::std::string& AIAPIDescription::ignored_check_aitensor(int index) const {
  // @@protoc_insertion_point(field_get:hiai.AIAPIDescription.ignored_check_aitensor)
  return ignored_check_aitensor_.Get(index);
}
inline ::std::string* AIAPIDescription::mutable_ignored_check_aitensor(int index) {
  // @@protoc_insertion_point(field_mutable:hiai.AIAPIDescription.ignored_check_aitensor)
  return ignored_check_aitensor_.Mutable(index);
}
inline void AIAPIDescription::set_ignored_check_aitensor(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:hiai.AIAPIDescription.ignored_check_aitensor)
  ignored_check_aitensor_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void AIAPIDescription::set_ignored_check_aitensor(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:hiai.AIAPIDescription.ignored_check_aitensor)
  ignored_check_aitensor_.Mutable(index)->assign(std::move(value));
}
#endif
inline void AIAPIDescription::set_ignored_check_aitensor(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  ignored_check_aitensor_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:hiai.AIAPIDescription.ignored_check_aitensor)
}
inline void AIAPIDescription::set_ignored_check_aitensor(int index, const char* value, size_t size) {
  ignored_check_aitensor_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hiai.AIAPIDescription.ignored_check_aitensor)
}
inline ::std::string* AIAPIDescription::add_ignored_check_aitensor() {
  // @@protoc_insertion_point(field_add_mutable:hiai.AIAPIDescription.ignored_check_aitensor)
  return ignored_check_aitensor_.Add();
}
inline void AIAPIDescription::add_ignored_check_aitensor(const ::std::string& value) {
  ignored_check_aitensor_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:hiai.AIAPIDescription.ignored_check_aitensor)
}
#if LANG_CXX11
inline void AIAPIDescription::add_ignored_check_aitensor(::std::string&& value) {
  ignored_check_aitensor_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:hiai.AIAPIDescription.ignored_check_aitensor)
}
#endif
inline void AIAPIDescription::add_ignored_check_aitensor(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  ignored_check_aitensor_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:hiai.AIAPIDescription.ignored_check_aitensor)
}
inline void AIAPIDescription::add_ignored_check_aitensor(const char* value, size_t size) {
  ignored_check_aitensor_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:hiai.AIAPIDescription.ignored_check_aitensor)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
AIAPIDescription::ignored_check_aitensor() const {
  // @@protoc_insertion_point(field_list:hiai.AIAPIDescription.ignored_check_aitensor)
  return ignored_check_aitensor_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
AIAPIDescription::mutable_ignored_check_aitensor() {
  // @@protoc_insertion_point(field_mutable_list:hiai.AIAPIDescription.ignored_check_aitensor)
  return &ignored_check_aitensor_;
}

// -------------------------------------------------------------------

// AIAPIDescriptionList

// repeated .hiai.AIAPIDescription api_descs = 1;
inline int AIAPIDescriptionList::api_descs_size() const {
  return api_descs_.size();
}
inline void AIAPIDescriptionList::clear_api_descs() {
  api_descs_.Clear();
}
inline const ::hiai::AIAPIDescription& AIAPIDescriptionList::api_descs(int index) const {
  // @@protoc_insertion_point(field_get:hiai.AIAPIDescriptionList.api_descs)
  return api_descs_.Get(index);
}
inline ::hiai::AIAPIDescription* AIAPIDescriptionList::mutable_api_descs(int index) {
  // @@protoc_insertion_point(field_mutable:hiai.AIAPIDescriptionList.api_descs)
  return api_descs_.Mutable(index);
}
inline ::hiai::AIAPIDescription* AIAPIDescriptionList::add_api_descs() {
  // @@protoc_insertion_point(field_add:hiai.AIAPIDescriptionList.api_descs)
  return api_descs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::hiai::AIAPIDescription >*
AIAPIDescriptionList::mutable_api_descs() {
  // @@protoc_insertion_point(field_mutable_list:hiai.AIAPIDescriptionList.api_descs)
  return &api_descs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::hiai::AIAPIDescription >&
AIAPIDescriptionList::api_descs() const {
  // @@protoc_insertion_point(field_list:hiai.AIAPIDescriptionList.api_descs)
  return api_descs_;
}

// -------------------------------------------------------------------

// AIOPDescription

// .hiai.AIOPDescription.OP_Type type = 1;
inline void AIOPDescription::clear_type() {
  type_ = 0;
}
inline ::hiai::AIOPDescription_OP_Type AIOPDescription::type() const {
  // @@protoc_insertion_point(field_get:hiai.AIOPDescription.type)
  return static_cast< ::hiai::AIOPDescription_OP_Type >(type_);
}
inline void AIOPDescription::set_type(::hiai::AIOPDescription_OP_Type value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:hiai.AIOPDescription.type)
}

// .hiai.AINNNodeDescription nnnode_desc = 2;
inline bool AIOPDescription::has_nnnode_desc() const {
  return this != internal_default_instance() && nnnode_desc_ != NULL;
}
inline void AIOPDescription::clear_nnnode_desc() {
  if (GetArenaNoVirtual() == NULL && nnnode_desc_ != NULL) {
    delete nnnode_desc_;
  }
  nnnode_desc_ = NULL;
}
inline const ::hiai::AINNNodeDescription& AIOPDescription::nnnode_desc() const {
  const ::hiai::AINNNodeDescription* p = nnnode_desc_;
  // @@protoc_insertion_point(field_get:hiai.AIOPDescription.nnnode_desc)
  return p != NULL ? *p : *reinterpret_cast<const ::hiai::AINNNodeDescription*>(
      &::hiai::_AINNNodeDescription_default_instance_);
}
inline ::hiai::AINNNodeDescription* AIOPDescription::release_nnnode_desc() {
  // @@protoc_insertion_point(field_release:hiai.AIOPDescription.nnnode_desc)
  
  ::hiai::AINNNodeDescription* temp = nnnode_desc_;
  nnnode_desc_ = NULL;
  return temp;
}
inline ::hiai::AINNNodeDescription* AIOPDescription::mutable_nnnode_desc() {
  
  if (nnnode_desc_ == NULL) {
    nnnode_desc_ = new ::hiai::AINNNodeDescription;
  }
  // @@protoc_insertion_point(field_mutable:hiai.AIOPDescription.nnnode_desc)
  return nnnode_desc_;
}
inline void AIOPDescription::set_allocated_nnnode_desc(::hiai::AINNNodeDescription* nnnode_desc) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete nnnode_desc_;
  }
  if (nnnode_desc) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      nnnode_desc = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, nnnode_desc, submessage_arena);
    }
    
  } else {
    
  }
  nnnode_desc_ = nnnode_desc;
  // @@protoc_insertion_point(field_set_allocated:hiai.AIOPDescription.nnnode_desc)
}

// .hiai.AIAPIDescription api_desc = 3;
inline bool AIOPDescription::has_api_desc() const {
  return this != internal_default_instance() && api_desc_ != NULL;
}
inline void AIOPDescription::clear_api_desc() {
  if (GetArenaNoVirtual() == NULL && api_desc_ != NULL) {
    delete api_desc_;
  }
  api_desc_ = NULL;
}
inline const ::hiai::AIAPIDescription& AIOPDescription::api_desc() const {
  const ::hiai::AIAPIDescription* p = api_desc_;
  // @@protoc_insertion_point(field_get:hiai.AIOPDescription.api_desc)
  return p != NULL ? *p : *reinterpret_cast<const ::hiai::AIAPIDescription*>(
      &::hiai::_AIAPIDescription_default_instance_);
}
inline ::hiai::AIAPIDescription* AIOPDescription::release_api_desc() {
  // @@protoc_insertion_point(field_release:hiai.AIOPDescription.api_desc)
  
  ::hiai::AIAPIDescription* temp = api_desc_;
  api_desc_ = NULL;
  return temp;
}
inline ::hiai::AIAPIDescription* AIOPDescription::mutable_api_desc() {
  
  if (api_desc_ == NULL) {
    api_desc_ = new ::hiai::AIAPIDescription;
  }
  // @@protoc_insertion_point(field_mutable:hiai.AIOPDescription.api_desc)
  return api_desc_;
}
inline void AIOPDescription::set_allocated_api_desc(::hiai::AIAPIDescription* api_desc) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete api_desc_;
  }
  if (api_desc) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      api_desc = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, api_desc, submessage_arena);
    }
    
  } else {
    
  }
  api_desc_ = api_desc;
  // @@protoc_insertion_point(field_set_allocated:hiai.AIOPDescription.api_desc)
}

// -------------------------------------------------------------------

// AIOPDescriptionList

// repeated .hiai.AIOPDescription op_descs = 1;
inline int AIOPDescriptionList::op_descs_size() const {
  return op_descs_.size();
}
inline void AIOPDescriptionList::clear_op_descs() {
  op_descs_.Clear();
}
inline const ::hiai::AIOPDescription& AIOPDescriptionList::op_descs(int index) const {
  // @@protoc_insertion_point(field_get:hiai.AIOPDescriptionList.op_descs)
  return op_descs_.Get(index);
}
inline ::hiai::AIOPDescription* AIOPDescriptionList::mutable_op_descs(int index) {
  // @@protoc_insertion_point(field_mutable:hiai.AIOPDescriptionList.op_descs)
  return op_descs_.Mutable(index);
}
inline ::hiai::AIOPDescription* AIOPDescriptionList::add_op_descs() {
  // @@protoc_insertion_point(field_add:hiai.AIOPDescriptionList.op_descs)
  return op_descs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::hiai::AIOPDescription >*
AIOPDescriptionList::mutable_op_descs() {
  // @@protoc_insertion_point(field_mutable_list:hiai.AIOPDescriptionList.op_descs)
  return &op_descs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::hiai::AIOPDescription >&
AIOPDescriptionList::op_descs() const {
  // @@protoc_insertion_point(field_list:hiai.AIOPDescriptionList.op_descs)
  return op_descs_;
}

// -------------------------------------------------------------------

// NodeDesc

// string name = 1;
inline void NodeDesc::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NodeDesc::name() const {
  // @@protoc_insertion_point(field_get:hiai.NodeDesc.name)
  return name_.GetNoArena();
}
inline void NodeDesc::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hiai.NodeDesc.name)
}
#if LANG_CXX11
inline void NodeDesc::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hiai.NodeDesc.name)
}
#endif
inline void NodeDesc::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hiai.NodeDesc.name)
}
inline void NodeDesc::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hiai.NodeDesc.name)
}
inline ::std::string* NodeDesc::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:hiai.NodeDesc.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NodeDesc::release_name() {
  // @@protoc_insertion_point(field_release:hiai.NodeDesc.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NodeDesc::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:hiai.NodeDesc.name)
}

// .hiai.AIConfig config = 2;
inline bool NodeDesc::has_config() const {
  return this != internal_default_instance() && config_ != NULL;
}
inline void NodeDesc::clear_config() {
  if (GetArenaNoVirtual() == NULL && config_ != NULL) {
    delete config_;
  }
  config_ = NULL;
}
inline const ::hiai::AIConfig& NodeDesc::config() const {
  const ::hiai::AIConfig* p = config_;
  // @@protoc_insertion_point(field_get:hiai.NodeDesc.config)
  return p != NULL ? *p : *reinterpret_cast<const ::hiai::AIConfig*>(
      &::hiai::_AIConfig_default_instance_);
}
inline ::hiai::AIConfig* NodeDesc::release_config() {
  // @@protoc_insertion_point(field_release:hiai.NodeDesc.config)
  
  ::hiai::AIConfig* temp = config_;
  config_ = NULL;
  return temp;
}
inline ::hiai::AIConfig* NodeDesc::mutable_config() {
  
  if (config_ == NULL) {
    config_ = new ::hiai::AIConfig;
  }
  // @@protoc_insertion_point(field_mutable:hiai.NodeDesc.config)
  return config_;
}
inline void NodeDesc::set_allocated_config(::hiai::AIConfig* config) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete config_;
  }
  if (config) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      config = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, config, submessage_arena);
    }
    
  } else {
    
  }
  config_ = config;
  // @@protoc_insertion_point(field_set_allocated:hiai.NodeDesc.config)
}

// repeated .hiai.AIModelDescription mode_desc = 3;
inline int NodeDesc::mode_desc_size() const {
  return mode_desc_.size();
}
inline void NodeDesc::clear_mode_desc() {
  mode_desc_.Clear();
}
inline const ::hiai::AIModelDescription& NodeDesc::mode_desc(int index) const {
  // @@protoc_insertion_point(field_get:hiai.NodeDesc.mode_desc)
  return mode_desc_.Get(index);
}
inline ::hiai::AIModelDescription* NodeDesc::mutable_mode_desc(int index) {
  // @@protoc_insertion_point(field_mutable:hiai.NodeDesc.mode_desc)
  return mode_desc_.Mutable(index);
}
inline ::hiai::AIModelDescription* NodeDesc::add_mode_desc() {
  // @@protoc_insertion_point(field_add:hiai.NodeDesc.mode_desc)
  return mode_desc_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::hiai::AIModelDescription >*
NodeDesc::mutable_mode_desc() {
  // @@protoc_insertion_point(field_mutable_list:hiai.NodeDesc.mode_desc)
  return &mode_desc_;
}
inline const ::google::protobuf::RepeatedPtrField< ::hiai::AIModelDescription >&
NodeDesc::mode_desc() const {
  // @@protoc_insertion_point(field_list:hiai.NodeDesc.mode_desc)
  return mode_desc_;
}

// -------------------------------------------------------------------

// EngineDesc

// uint32 id = 1;
inline void EngineDesc::clear_id() {
  id_ = 0u;
}
inline ::google::protobuf::uint32 EngineDesc::id() const {
  // @@protoc_insertion_point(field_get:hiai.EngineDesc.id)
  return id_;
}
inline void EngineDesc::set_id(::google::protobuf::uint32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:hiai.EngineDesc.id)
}

// .hiai.EngineDesc.EngineType type = 2;
inline void EngineDesc::clear_type() {
  type_ = 0;
}
inline ::hiai::EngineDesc_EngineType EngineDesc::type() const {
  // @@protoc_insertion_point(field_get:hiai.EngineDesc.type)
  return static_cast< ::hiai::EngineDesc_EngineType >(type_);
}
inline void EngineDesc::set_type(::hiai::EngineDesc_EngineType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:hiai.EngineDesc.type)
}

// string name = 3;
inline void EngineDesc::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& EngineDesc::name() const {
  // @@protoc_insertion_point(field_get:hiai.EngineDesc.name)
  return name_.GetNoArena();
}
inline void EngineDesc::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hiai.EngineDesc.name)
}
#if LANG_CXX11
inline void EngineDesc::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hiai.EngineDesc.name)
}
#endif
inline void EngineDesc::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hiai.EngineDesc.name)
}
inline void EngineDesc::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hiai.EngineDesc.name)
}
inline ::std::string* EngineDesc::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:hiai.EngineDesc.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EngineDesc::release_name() {
  // @@protoc_insertion_point(field_release:hiai.EngineDesc.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EngineDesc::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:hiai.EngineDesc.name)
}

// repeated string so_name = 4;
inline int EngineDesc::so_name_size() const {
  return so_name_.size();
}
inline void EngineDesc::clear_so_name() {
  so_name_.Clear();
}
inline const ::std::string& EngineDesc::so_name(int index) const {
  // @@protoc_insertion_point(field_get:hiai.EngineDesc.so_name)
  return so_name_.Get(index);
}
inline ::std::string* EngineDesc::mutable_so_name(int index) {
  // @@protoc_insertion_point(field_mutable:hiai.EngineDesc.so_name)
  return so_name_.Mutable(index);
}
inline void EngineDesc::set_so_name(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:hiai.EngineDesc.so_name)
  so_name_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void EngineDesc::set_so_name(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:hiai.EngineDesc.so_name)
  so_name_.Mutable(index)->assign(std::move(value));
}
#endif
inline void EngineDesc::set_so_name(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  so_name_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:hiai.EngineDesc.so_name)
}
inline void EngineDesc::set_so_name(int index, const char* value, size_t size) {
  so_name_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hiai.EngineDesc.so_name)
}
inline ::std::string* EngineDesc::add_so_name() {
  // @@protoc_insertion_point(field_add_mutable:hiai.EngineDesc.so_name)
  return so_name_.Add();
}
inline void EngineDesc::add_so_name(const ::std::string& value) {
  so_name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:hiai.EngineDesc.so_name)
}
#if LANG_CXX11
inline void EngineDesc::add_so_name(::std::string&& value) {
  so_name_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:hiai.EngineDesc.so_name)
}
#endif
inline void EngineDesc::add_so_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  so_name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:hiai.EngineDesc.so_name)
}
inline void EngineDesc::add_so_name(const char* value, size_t size) {
  so_name_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:hiai.EngineDesc.so_name)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
EngineDesc::so_name() const {
  // @@protoc_insertion_point(field_list:hiai.EngineDesc.so_name)
  return so_name_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
EngineDesc::mutable_so_name() {
  // @@protoc_insertion_point(field_mutable_list:hiai.EngineDesc.so_name)
  return &so_name_;
}

// .hiai.EngineDesc.RunSide side = 5;
inline void EngineDesc::clear_side() {
  side_ = 0;
}
inline ::hiai::EngineDesc_RunSide EngineDesc::side() const {
  // @@protoc_insertion_point(field_get:hiai.EngineDesc.side)
  return static_cast< ::hiai::EngineDesc_RunSide >(side_);
}
inline void EngineDesc::set_side(::hiai::EngineDesc_RunSide value) {
  
  side_ = value;
  // @@protoc_insertion_point(field_set:hiai.EngineDesc.side)
}

// int32 priority = 6;
inline void EngineDesc::clear_priority() {
  priority_ = 0;
}
inline ::google::protobuf::int32 EngineDesc::priority() const {
  // @@protoc_insertion_point(field_get:hiai.EngineDesc.priority)
  return priority_;
}
inline void EngineDesc::set_priority(::google::protobuf::int32 value) {
  
  priority_ = value;
  // @@protoc_insertion_point(field_set:hiai.EngineDesc.priority)
}

// uint32 instance_cnt = 7;
inline void EngineDesc::clear_instance_cnt() {
  instance_cnt_ = 0u;
}
inline ::google::protobuf::uint32 EngineDesc::instance_cnt() const {
  // @@protoc_insertion_point(field_get:hiai.EngineDesc.instance_cnt)
  return instance_cnt_;
}
inline void EngineDesc::set_instance_cnt(::google::protobuf::uint32 value) {
  
  instance_cnt_ = value;
  // @@protoc_insertion_point(field_set:hiai.EngineDesc.instance_cnt)
}

// repeated uint32 next_node_id = 8;
inline int EngineDesc::next_node_id_size() const {
  return next_node_id_.size();
}
inline void EngineDesc::clear_next_node_id() {
  next_node_id_.Clear();
}
inline ::google::protobuf::uint32 EngineDesc::next_node_id(int index) const {
  // @@protoc_insertion_point(field_get:hiai.EngineDesc.next_node_id)
  return next_node_id_.Get(index);
}
inline void EngineDesc::set_next_node_id(int index, ::google::protobuf::uint32 value) {
  next_node_id_.Set(index, value);
  // @@protoc_insertion_point(field_set:hiai.EngineDesc.next_node_id)
}
inline void EngineDesc::add_next_node_id(::google::protobuf::uint32 value) {
  next_node_id_.Add(value);
  // @@protoc_insertion_point(field_add:hiai.EngineDesc.next_node_id)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
EngineDesc::next_node_id() const {
  // @@protoc_insertion_point(field_list:hiai.EngineDesc.next_node_id)
  return next_node_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
EngineDesc::mutable_next_node_id() {
  // @@protoc_insertion_point(field_mutable_list:hiai.EngineDesc.next_node_id)
  return &next_node_id_;
}

// bool user_input_cb = 9;
inline void EngineDesc::clear_user_input_cb() {
  user_input_cb_ = false;
}
inline bool EngineDesc::user_input_cb() const {
  // @@protoc_insertion_point(field_get:hiai.EngineDesc.user_input_cb)
  return user_input_cb_;
}
inline void EngineDesc::set_user_input_cb(bool value) {
  
  user_input_cb_ = value;
  // @@protoc_insertion_point(field_set:hiai.EngineDesc.user_input_cb)
}

// bool user_output_cb = 10;
inline void EngineDesc::clear_user_output_cb() {
  user_output_cb_ = false;
}
inline bool EngineDesc::user_output_cb() const {
  // @@protoc_insertion_point(field_get:hiai.EngineDesc.user_output_cb)
  return user_output_cb_;
}
inline void EngineDesc::set_user_output_cb(bool value) {
  
  user_output_cb_ = value;
  // @@protoc_insertion_point(field_set:hiai.EngineDesc.user_output_cb)
}

// repeated .hiai.NodeDesc oper = 11;
inline int EngineDesc::oper_size() const {
  return oper_.size();
}
inline void EngineDesc::clear_oper() {
  oper_.Clear();
}
inline const ::hiai::NodeDesc& EngineDesc::oper(int index) const {
  // @@protoc_insertion_point(field_get:hiai.EngineDesc.oper)
  return oper_.Get(index);
}
inline ::hiai::NodeDesc* EngineDesc::mutable_oper(int index) {
  // @@protoc_insertion_point(field_mutable:hiai.EngineDesc.oper)
  return oper_.Mutable(index);
}
inline ::hiai::NodeDesc* EngineDesc::add_oper() {
  // @@protoc_insertion_point(field_add:hiai.EngineDesc.oper)
  return oper_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::hiai::NodeDesc >*
EngineDesc::mutable_oper() {
  // @@protoc_insertion_point(field_mutable_list:hiai.EngineDesc.oper)
  return &oper_;
}
inline const ::google::protobuf::RepeatedPtrField< ::hiai::NodeDesc >&
EngineDesc::oper() const {
  // @@protoc_insertion_point(field_list:hiai.EngineDesc.oper)
  return oper_;
}

// -------------------------------------------------------------------

// GraphInitDesc

// int32 priority = 1;
inline void GraphInitDesc::clear_priority() {
  priority_ = 0;
}
inline ::google::protobuf::int32 GraphInitDesc::priority() const {
  // @@protoc_insertion_point(field_get:hiai.GraphInitDesc.priority)
  return priority_;
}
inline void GraphInitDesc::set_priority(::google::protobuf::int32 value) {
  
  priority_ = value;
  // @@protoc_insertion_point(field_set:hiai.GraphInitDesc.priority)
}

// -------------------------------------------------------------------

// GeneralFileBuffer

// bytes raw_data = 1;
inline void GeneralFileBuffer::clear_raw_data() {
  raw_data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GeneralFileBuffer::raw_data() const {
  // @@protoc_insertion_point(field_get:hiai.GeneralFileBuffer.raw_data)
  return raw_data_.GetNoArena();
}
inline void GeneralFileBuffer::set_raw_data(const ::std::string& value) {
  
  raw_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hiai.GeneralFileBuffer.raw_data)
}
#if LANG_CXX11
inline void GeneralFileBuffer::set_raw_data(::std::string&& value) {
  
  raw_data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hiai.GeneralFileBuffer.raw_data)
}
#endif
inline void GeneralFileBuffer::set_raw_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  raw_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hiai.GeneralFileBuffer.raw_data)
}
inline void GeneralFileBuffer::set_raw_data(const void* value, size_t size) {
  
  raw_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hiai.GeneralFileBuffer.raw_data)
}
inline ::std::string* GeneralFileBuffer::mutable_raw_data() {
  
  // @@protoc_insertion_point(field_mutable:hiai.GeneralFileBuffer.raw_data)
  return raw_data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GeneralFileBuffer::release_raw_data() {
  // @@protoc_insertion_point(field_release:hiai.GeneralFileBuffer.raw_data)
  
  return raw_data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GeneralFileBuffer::set_allocated_raw_data(::std::string* raw_data) {
  if (raw_data != NULL) {
    
  } else {
    
  }
  raw_data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), raw_data);
  // @@protoc_insertion_point(field_set_allocated:hiai.GeneralFileBuffer.raw_data)
}

// string file_name = 2;
inline void GeneralFileBuffer::clear_file_name() {
  file_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GeneralFileBuffer::file_name() const {
  // @@protoc_insertion_point(field_get:hiai.GeneralFileBuffer.file_name)
  return file_name_.GetNoArena();
}
inline void GeneralFileBuffer::set_file_name(const ::std::string& value) {
  
  file_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hiai.GeneralFileBuffer.file_name)
}
#if LANG_CXX11
inline void GeneralFileBuffer::set_file_name(::std::string&& value) {
  
  file_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hiai.GeneralFileBuffer.file_name)
}
#endif
inline void GeneralFileBuffer::set_file_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  file_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hiai.GeneralFileBuffer.file_name)
}
inline void GeneralFileBuffer::set_file_name(const char* value, size_t size) {
  
  file_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hiai.GeneralFileBuffer.file_name)
}
inline ::std::string* GeneralFileBuffer::mutable_file_name() {
  
  // @@protoc_insertion_point(field_mutable:hiai.GeneralFileBuffer.file_name)
  return file_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GeneralFileBuffer::release_file_name() {
  // @@protoc_insertion_point(field_release:hiai.GeneralFileBuffer.file_name)
  
  return file_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GeneralFileBuffer::set_allocated_file_name(::std::string* file_name) {
  if (file_name != NULL) {
    
  } else {
    
  }
  file_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), file_name);
  // @@protoc_insertion_point(field_set_allocated:hiai.GeneralFileBuffer.file_name)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace hiai

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::hiai::AIModelDescription_Frequency> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::hiai::AIModelDescription_Frequency>() {
  return ::hiai::AIModelDescription_Frequency_descriptor();
}
template <> struct is_proto_enum< ::hiai::AIModelDescription_DeviceType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::hiai::AIModelDescription_DeviceType>() {
  return ::hiai::AIModelDescription_DeviceType_descriptor();
}
template <> struct is_proto_enum< ::hiai::AIModelDescription_Framework> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::hiai::AIModelDescription_Framework>() {
  return ::hiai::AIModelDescription_Framework_descriptor();
}
template <> struct is_proto_enum< ::hiai::AIOPDescription_OP_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::hiai::AIOPDescription_OP_Type>() {
  return ::hiai::AIOPDescription_OP_Type_descriptor();
}
template <> struct is_proto_enum< ::hiai::EngineDesc_RunSide> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::hiai::EngineDesc_RunSide>() {
  return ::hiai::EngineDesc_RunSide_descriptor();
}
template <> struct is_proto_enum< ::hiai::EngineDesc_EngineType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::hiai::EngineDesc_EngineType>() {
  return ::hiai::EngineDesc_EngineType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_ai_5ftypes_2eproto__INCLUDED
